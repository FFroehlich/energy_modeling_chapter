\documentclass[11pt]{article}

    \usepackage[breakable]{tcolorbox}
    \usepackage{parskip} % Stop auto-indenting (to mimic markdown behaviour)
    
    \usepackage{iftex}
    \ifPDFTeX
    	\usepackage[T1]{fontenc}
    	\usepackage{mathpazo}
    \else
    	\usepackage{fontspec}
    \fi

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    %\let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage[aboveskip=1pt,labelfont=bf,labelsep=period,justification=raggedright,singlelinecheck=off]{caption}
    %\DeclareCaptionFormat{nocaption}{}
    %\captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}
    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range
    \makeatletter % fix for grffile with XeLaTeX
    \def\Gread@@xetex#1{%
      \IfFileExists{"\Gin@base".bb}%
      {\Gread@eps{\Gin@base.bb}}%
      {\Gread@@xetex@aux#1}%
    }
    \makeatother

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{titling}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}
    

    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    \newcommand{\dims}[1]{{n_{#1}}}
    % Document parameters
    % Document title
    \title{A Practical Guide for the Efficient Formulation and Calibration
of Large, Energy Rule-Based Models of Cellular Signal
Transduction}
\author{
Fabian Fr\"ohlich\,$^{\text{1}}$
}
\date{%
$^{\text{\sf 1}}$Department of Systems Biology, Harvard Medical School, Boston, MA 02115, USA,\\
}
    
% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb. 
    \makeatletter
        \newbox\Wrappedcontinuationbox 
        \newbox\Wrappedvisiblespacebox 
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}} 
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}} 
        \newcommand*\Wrappedcontinuationindent {3ex } 
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox} 
        % Take advantage of the already applied Pygments mark-up to insert 
        % potential linebreaks for TeX processing. 
        %        {, <, #, %, $, ' and ": go to next line. 
        %        _, }, ^, &, >, - and ~: stay at end of broken line. 
        % Use of \textquotesingle for straight quote. 
        \newcommand*\Wrappedbreaksatspecials {% 
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}% 
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}% 
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}% 
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}% 
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}% 
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}% 
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}% 
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}% 
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}% 
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}% 
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}% 
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}% 
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}% 
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}% 
        } 
        % Some characters . , ; ? ! / are not pygmentized. 
        % This macro makes them "active" and they will insert potential linebreaks 
        \newcommand*\Wrappedbreaksatpunct {% 
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}% 
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}% 
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}% 
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}% 
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}% 
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}% 
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}% 
            \catcode`\.\active
            \catcode`\,\active 
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active 
            \lccode`\~`\~ 	
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%
        
        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active 	
        \OriginalVerbatim[#1,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{F7F7F7}
    
    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        \ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}
    }
    

    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

\begin{document}
    
    \maketitle
    
    

    \hypertarget{abstract}{%
\section*{Abstract}\label{abstract}}

    Aberrant signal transduction leads to complex diseases such as cancer.
To rationally design treatment strategies with small molecule
inhibitors, computational models have to be employed. Energy- and
rule-based models allow the construction of mechanistic ordinary
differential equation models based on structural insights. The detailed,
energy-based description often generates large models, which are
difficult to calibrate on experimental data. In this chapter, we provide
a detailed, interactive protocol for the programmatic formulation and
calibration of such large, energy- and rule-based models of cellular
signal transduction based on an example model describing the action of
RAF inhibitors on MAPK signaling. An interactive version of this chapter
is available as jupyter notebook at
\href{https:://github.com/FFroehlich/energy_modeling_chapter}{github.com/FFroehlich/energy\_modeling\_chapter}.

    \hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

    Cells use signal transduction to respond to extracellular cues,
controlling a variety of different cellular processes such as
proliferation, development and environmental adaption
~\cite{2754712/YK9CS8BY}. Signal transduction is initiated by the binding
of extracellular ligands to transmembrane receptors
~\cite{2754712/QR4JIKLV} and then propagated through phosphorylation
cascades~\cite{2754712/B6ZP8LH6,2754712/NPR437GQ}, ultimately
controlling gene expression through modulation of transcription factor
activity. Mutations and changes in protein expression levels can
dysregulate signal transduction leading to a variety of different
diseases such as cancer~\cite{2754712/L8NRTXRQ}. Small molecule
inhibitors can be used to target specific proteins that participate in
aberrant signal transduction~\cite{2754712/7ZXBI6XG}. However, feedback
mechanisms and cross-talk between signaling cascades, which are
ubiquitous to cellular signal transduction, lead to complex, non-linear
responses to drug inhibition~\cite{2754712/URVR5RD5}, making it
difficult to anticipate the phenotypic response or resistance to these
inhibitors. Accordingly, computational models that describe signal
transduction, and the effect of drug perturbations on it, are required
for the rational selection and dosage of targeted inhibitors
~\cite{2754712/DUK5BLQ4}. Mechanistic computational models of cellular
signal transduction translate biological knowledge into executable
mathematical formulations~\cite{2754712/6JVZVNVK}. To this end, ordinary
differential equations (ODE) models are a popular modeling approach, as
they can describe temporal dynamics and feedback mechanisms
~\cite{2754712/X784IDZJ}. Moreover, state variables and parameters
correspond to biophysical entities, facilitating a direct interpretation
of model simulations and predictions.

    Formulation of such models is often a long, labour intensive process,
especially for large models. Instead of directly writing model
equations, a tedious and error-prone process, it is advisable to use
some kind of abstraction when writing models. For example, the Systems
Biology Markup Language (SBML)~\cite{2754712/NF7FZULE} encodes models
using concepts such as reactions and events, which can then be
translated into differential equation models. Rule-based formats such as
Kappa~\cite{2754712/NAKF6985} or BioNetGen~\cite{2754712/M82A4YPP}
employ even higher levels of abstractions and describe model equations
in terms of rules, which are generalizations of reactions
~\cite{2754712/MIF24GAE}. While such abstractions can limit what models
can be expressed, they also permit a more compact model description. A
recent extension to rule-based models are energy rule-based models
~\cite{2754712/6CAKFQQP,2754712/QTNJGKHE}, which provide an
additional layer of abstraction by enabling the specification of
reaction rates in terms of energies. Conceptually, energies permit the
theoretically sound formulation of reaction rates based on transition
theory and provide a rigorous way of specifying context dependent
reaction rates based on structural insights~\cite{2754712/7TJH2IAK,2754712/DI7IDWLV}. Practically, energy based models enforce
thermodynamic constraints such as the Wegscheider-Lewis cycle conditions
~\cite{2754712/VAJ8A9TA}, which ensure the conservation of energy in
oligomerization processes. This is particularly relevant for the
specification of context dependent inhibitor affinities. For example,
many RAF inhibitors have different affinities for RAF monomers and
dimers, which causes for the clinically observed phenomenon of
``paradoxical activation'' in which signaling in RAF mutant cancer cells
in inhibited, but signaling in RAS mutant cancer cells is amplified
~\cite{2754712/68C3KR4X,2754712/GPZDY42G,2754712/46UNKAAD}.

    Calibration of large models can also be challenging. During model
calibration, parameter values are tuned such that model simulations
agree with experimental data, which improves the predictive performance
of models. Agreement between model simulations and experiments can be
quantified using likelihood-based objective functions, in which case
model calibration can be implemented through minimization of the
respective objective function. For larger models, gradient-based
optimization methods perform well~\cite{2754712/INKV577L}. However, for
non-linear models, analytical solutions to model equations are rarely
available, which means that numerical integration is necessary for
evaluation of the objective function and its derivatives. Accordingly,
gradient-based methods not only require integration of model equations,
but also sensitivity equations, which quantify the dependence of
simulations on model parameters. For large models, adjoint sensitivity
analysis is an effective way of computing these sensitivities, but also
comes with its drawbacks such as not permitting the computation of cheap
approximations to the second order derivative~\cite{2754712/MKPQ9727}.

    Model formulation and calibration for large models can be a daunting
task~\cite{2754712/C7C8DJNE}, even when using specialized software
tools. Input formats such as SBML or PEtab~\cite{2754712/86CV69R2}
permit the standardized problem formulation, which allows the automation
of the majority of steps. However, manual interventions are still
occasionally necessary to achieve optimal performance. These manual
interventions often require substantial practical experience as well as
theoretical background knowledge, which creates a high barrier to entry
and means that successful development and application of large models is
rarely possible without guidance from experts. To rectify this
situation, we here provide a detailed step-by-step protocol for the
calibration of a large scale model introduced in~\cite{2754712/I4JQ4DMV}
and~\cite{2754712/Y3E9IYH8}. In contrast to previous protocols for ODE
model calibrations~\cite{2754712/3DK88XY2}, this protocol includes a
description of energy-based model formulation, focuses on large-scale
models of intracellular signaling and includes an interactive jupyter
notebook which allows reproduction of all results. As in other
protocols, theoretical background is provided when appropriate. For
additional analysis steps including identifiability, uncertainty
analysis or model selection, users should consult previously published
reviews and protocols . This protocol uses the python toolboxes PySB~\cite{2754712/7D6BBY4A},
PEtab~\cite{2754712/86CV69R2}, AMICI~\cite{2754712/HBAI2XHJ}, pyPESTO and fides~\cite{2754712/RUR9I9SQ} and is accompanied by a jupyter
notebook that permits the interactive reproduction of results.

    \hypertarget{mathematical-problem-formulation}{%
\section{Mathematical Problem
Formulation}\label{mathematical-problem-formulation}}

For ODE models, the temporal
evolution of abundances of \(\dims{x}\) different molecular species
\(x_i\) is determined by the vector field \(\textbf{f}\) and the initial
conditions \(\textbf{x}_0\):

\begin{equation}
\dot{\textbf{x}}=\textbf{f}(t,\textbf{x},\boldsymbol{\gamma}),\quad \textbf{x}(t_0) = \textbf{x}_0(\boldsymbol{\gamma}).
\label{eq:ode}
\end{equation}

Both \(\textbf{f}\) and \(\textbf{x}_0\) may depend on dynamic
parameters \(\boldsymbol{\gamma}\), which may include kinetic parameters
such as catalytic or binding rates or condition parameters such as
ligand or drug concentrations.

Calibration is performed by comparing model simulations, i.e., solutions
\(\textbf{x}\) that satisfy \(\eqref{eq:ode}\), to experimental data
\(\bar{\textbf{y}}\). As direct measurement of \(\textbf{x}\) is usually
experimentally not possible, observables

\begin{equation}
\textbf{y}(t,\boldsymbol{\gamma},\boldsymbol{\xi}) = \textbf{g}(\textbf{x}(t,\boldsymbol{\gamma}),\boldsymbol{\xi})
\label{eq:observable}
\end{equation}

are introduced, which may depend on abundances \(\textbf{x}\) as well as
observable parameters \(\boldsymbol{\xi}\) such as scaling parameters or
offsets. The agreement between model observables \(\textbf{y}\) and
experimental measurements \(\bar{\textbf{y}}\) can be quantified
according to the assumed noise model. A common assumption is that the
measurement noise for \(\dims{y}\) observables \(y_i\) is additive and
independent, normally distributed:

\begin{equation}
\bar{y}_{i} = y_i(t,\boldsymbol{\gamma},\boldsymbol{\xi}) + \epsilon_{i} \quad \epsilon_{i} \overset{id}{\sim} \mathcal{N}(0,\sigma_{i}^2(\boldsymbol{\psi})),
\label{eq:noise}
\end{equation}

where \(\boldsymbol{\psi}\) are noise parameters that encode the
standard deviations \(\boldsymbol{\sigma}\). Using this noise model, the
negative log-likelihood

\begin{equation}
\begin{aligned}
J(\boldsymbol{\theta}) =&  \frac{1}{2} \sum_{i=k}^\dims{k} \sum_{(i,j) \in T_k} \log\left(2\pi\sigma_{i}^2(\boldsymbol{\Psi}_{ijk}(\boldsymbol{\theta}))\right) + \left(\frac{\bar{y}_{ijk} - y_{i}(t_j,\boldsymbol{\Gamma}_k(\boldsymbol{\theta}),\boldsymbol{\Xi}_{ijk}(\boldsymbol{\theta}))}{\sigma_{i}(\boldsymbol{\Psi}_{ijk}(\boldsymbol{\theta}))}\right)^2
\label{eq:objective}
\end{aligned}
\end{equation}

statistically rigorously quantifies the agreement between experimental
data and model simulations, where \(\boldsymbol{\theta}\) are the free,
unknown parameters, \(T_k\) is the set of time points \(t_j\) and
observable \(y_i\) index combinations that were measured in the \(k\)-th
out of \(\dims{k}\) experimental conditions, \(\boldsymbol{\Psi}_{ijk}\)
is a function that maps free parameters \(\boldsymbol{\theta}\) to
observable, time point and condition specific noise parameters
\(\boldsymbol{\psi}\), \(\boldsymbol{\Xi}_{ijk}\) is a function that
maps free parameters \(\boldsymbol{\theta}\) to observable, time point
and condition specific observable parameters \(\boldsymbol{\xi}\) and
\(\boldsymbol{\Gamma_{k}}\) is a function that maps free parameters
\(\boldsymbol{\theta}\) to condition specific dynamic parameters
\(\boldsymbol{\gamma}\). As the logarithm is a strictly monotonously
increasing function, the minimization of \(J(\boldsymbol{\theta})\) is
equivalent to the maximization of the likelihood. Therefore, the
corresponding minimization problem

\begin{equation}
\boldsymbol{\theta}^* = \arg \min_{\boldsymbol{\theta} \in \Theta} J(\boldsymbol{\theta}),
\label{eq:mle}
\end{equation}

will infer the Maximum Likelihood Estimate \(\boldsymbol{\theta}^*\) for
free parameters \(\boldsymbol{\theta}\), where the search domain
\(\Theta\subset{\mathbb{R}}^{\dims{\theta}}\) restricts the
\(\boldsymbol{\theta}\) to values that are biologically plausible and
are less subject to numerical integration failures. For most problems,
\(\Theta\) is chosen as tensor product of scalar search domains
\((\mathcal{L}_l,\mathcal{U}_l)\) with lower and upper boundaries
\(\mathcal{L}_l < \mathcal{U}_l\) and
\(\mathcal{L}_l, \mathcal{U}_l \in \mathbb{R}\cup\{-\infty,\infty\}\)
for every parameter \(\theta_l\).

    \hypertarget{formulating-a-thermodynamic-model-of-raf-inhibition-in-pysb}{%
\section{Formulating a Thermodynamic Model of RAF inhibition in
PySB}\label{formulating-a-thermodynamic-model-of-raf-inhibition-in-pysb}}

    In the following, we will specify the model, which in turn defines the
right hand side \(\textbf{f}\) and the initial conditions
\(\textbf{x}_0\) of the model equations. We will specify the model using
the rule-based modeling framework PySB, which instead of direct
specification of \(\textbf{f}\), programmatically encodes model
structure in a modular, object oriented way, ensuring reusability,
composability and extendability of models~\cite{2754712/7D6BBY4A}. To
start model specification, we instantiate a PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Model}{\texttt{Model}}
with name \texttt{thermo\_raf}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{1}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pysb} \PY{k+kn}{import} \PY{n}{Model}
\PY{n}{model} \PY{o}{=} \PY{n}{Model}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{thermo\PYZus{}raf}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{protein-species}{%
\subsection{Protein Species}\label{protein-species}}

As first step of model construction, we have to define all molecules
that we want to account for. In PySB, this is done by instantiating the
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Monomer}{\texttt{Monomer}}
class. Each monomer is initialized by a unique identifier, a list of
sites as well as, optionally, a list of possible states for each site.
Sites typically correspond to binding domains or residues that can be
mutated or modified post-translationally, where the site states encode
the different all possible mutations or post-translational modifications
for each site. All sites, independent of whether possible states were
specified or not, can form a bond with other sites, permitting the
description of macromolecular complexes.

Here, we will define monomers \texttt{BRAF} and \texttt{CRAF} which both
feature the interaction sites \texttt{RBD} (interaction domain with
RAS), \texttt{raf} (dimerization domain) and \texttt{rafi} (inhibitor
binding site). For BRAF we also add a mutation sites for the 600th amino
acid, which can take values \texttt{V} (valine, wildtype) or \texttt{E}
(glutamic acid, oncogenic mutation).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pysb} \PY{k+kn}{import} \PY{n}{Monomer}
\PY{n}{Monomer}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BRAF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{AA600}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RBD}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{raf}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{rafi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{AA600}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{E}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{V}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
\PY{n}{Monomer}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{CRAF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RBD}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{raf}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{rafi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    Next, we will specify initial concentrations. For this model, the
concentration of all molecular species will be in \(\mu\mathrm{M}\).
However, we will use protein counts per cell derived from absolute
proteomics to inform initial conditions. Accordingly, parameters that
define initial concentrations have to be transformed from molecule per
cell to \(\mu\mathrm{M}\), which is achieved by dividing them by cell
volume (here assumed to be \(1pL = 10^{-12} L\)) and the Avogadro
constant (\(6.022 10^{23}\) molecules) and multiplying with \(10^{6}\)
to account for the unit prefix \(\mu\).

In the following code, we first introduce two PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Expression}{\texttt{Expression}}s
that specify the Avogadro constant and cell volume. As with most model
components, PySB automatically creates workspace variables with the
respective identifier as variable names, simplifying the programmatic
reference to components. Next, we introduce two dynamic parameters
(\(\boldsymbol{\gamma}\), see \(\eqref{eq:ode}\)) as PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Parameter}{\texttt{Parameter}}s
\texttt{BRAF\_0} and \texttt{CRAF\_0} that define initial abundances as
molecules per cell and convert these abundances to concentrations in
\(\mu\mathrm{M}\) using the expressions \texttt{initBRAF} and
\texttt{initCRAF}. These expressions are then used to define the initial
abundances for the two monomer species \texttt{CRAF} and \texttt{BRAF}
using the PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Initial}{\texttt{Initial}}
class, which specifies \(\textbf{x}_0\) for the respective molecular
species \(x_i\). In PySB, a molecular species is defined by a pattern,
which is created by invoking the respective monomer with the state of
each site as keyword argument. For initial conditions, the respective
patterns have to be explicit, i.e., the states of all sites have to
specified. For the initial conditions, we specify that all sites are
unbound (denoted by \texttt{None}), with the exception of the the
\texttt{AA600} site. For the \texttt{AA600} site we have to pick one of
the previously specified states, which we do by specifying the oncogenic
variant denoted by \texttt{E}. For all molecular species without an
explicit instantiation of
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Initial}{\texttt{Initial}},
the respective entry in \(\textbf{x}_0\) is set to \(0\).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pysb} \PY{k+kn}{import} \PY{n}{Parameter}\PY{p}{,} \PY{n}{Expression}\PY{p}{,} \PY{n}{Initial}
\PY{k+kn}{import} \PY{n+nn}{sympy} \PY{k}{as} \PY{n+nn}{sp}

\PY{c+c1}{\PYZsh{} define Avogadro constant and volume as hardcoded expressions}
\PY{n}{Expression}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{N\PYZus{}Avogadro}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{sp}\PY{o}{.}\PY{n}{Float}\PY{p}{(}\PY{l+m+mf}{6.02214076e+23}\PY{p}{)}\PY{p}{)}
\PY{n}{Expression}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{volume}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{sp}\PY{o}{.}\PY{n}{Float}\PY{p}{(}\PY{l+m+mf}{1e\PYZhy{}12}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} define initial abundance parameters }
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BRAF\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{CRAF\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} convert initial abundances to concentrations}
\PY{n}{Expression}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{initBRAF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mf}{1000000.0}\PY{o}{*}\PY{n}{BRAF\PYZus{}0}\PY{o}{/}\PY{p}{(}\PY{n}{N\PYZus{}Avogadro}\PY{o}{*}\PY{n}{volume}\PY{p}{)}\PY{p}{)}
\PY{n}{Expression}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{initCRAF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mf}{1000000.0}\PY{o}{*}\PY{n}{CRAF\PYZus{}0}\PY{o}{/}\PY{p}{(}\PY{n}{N\PYZus{}Avogadro}\PY{o}{*}\PY{n}{volume}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} define initial molecular species}
\PY{n}{Initial}\PY{p}{(}\PY{n}{BRAF}\PY{p}{(}\PY{n}{AA600}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{E}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{RBD}\PY{o}{=}\PY{k+kc}{None}\PY{p}{,} \PY{n}{raf}\PY{o}{=}\PY{k+kc}{None}\PY{p}{,} \PY{n}{rafi}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)}\PY{p}{,} \PY{n}{initBRAF}\PY{p}{)}
\PY{n}{Initial}\PY{p}{(}\PY{n}{CRAF}\PY{p}{(}\PY{n}{RBD}\PY{o}{=}\PY{k+kc}{None}\PY{p}{,} \PY{n}{raf}\PY{o}{=}\PY{k+kc}{None}\PY{p}{,} \PY{n}{rafi}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)}\PY{p}{,} \PY{n}{initCRAF}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{protein-interactions}{%
\subsection{Protein Interactions}\label{protein-interactions}}

For rule-based models, all dynamic interactions are specified as rules.
PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Rule}{\texttt{Rule}}s
are generalizations of biochemical reactions and their action is defined
by a reactant pattern and a product pattern. When applied to a molecular
species, the action of the rule, i.e., the respective biochemical
reaction, is implemented by applying the difference between the reactant
and the product pattern to a match of the reactant pattern in a
molecular species. In contrast to initials, the reactant pattern and
product pattern do not have to be explicit and a single rule can define
multiple different biochemical reactions, depending in how often and in
how many molecular species the reactant pattern occurs.

Non-thermodynamic rules additionally require forward reaction rates
\(k_f\) and, if applicable, reverse reaction rates \(k_r\). In contrast,
thermodynamic rules are specified in terms of activation energy \(E_a\)
and the phenomenological constant \(\phi\), the convex combination
parameter which encodes how much changes in free energy affect forwards
and reverse rates. For thermodynamic rules, the reaction rate also
depends on the free energy difference between reactants and products of
the reaction. The forward \(k_f\) and reverse \(k_r\) reaction rates are
computed using the Arrhenius theory of reaction rates

\[k_f=\exp( - (E_a + \phi \Delta G)), \quad k_r=\exp( - (E_a + (\phi - 1) \Delta G))\]

with

\[\Delta G = - \sum_{r \in R} \Delta \Delta G_r + \sum_{p \in P} \Delta \Delta G_p\]

where \(E_a\) is the activation energy of the reaction, i.e., the free
energy difference between the reactant state and the transition state,
\(\Delta G\) is the free energy difference between the reactant and the
product states and \(\Delta \Delta G_r\) and \(\Delta \Delta G_p\) are
the free energy modifiers that apply to the reactants \(r\) in \(R\) and
the products \(p\) in \(P\) respectively. All energies are assumed to be
normalized by the inverse of the product between temperature and
Boltzmann constant \(\frac{1}{RT}\). The \(\Delta \Delta G_r\) and
\(\Delta \Delta G_p\) energies can be specified by using the PySB
\texttt{EnergyPattern} class. When calculating reaction rates, energy
BioNetGen (eBNG) not only accounts for \texttt{EnergyPattern}s that
apply to the reactant and product patterns specified in the rule, but
also those EnergyPatterns that specifically apply to reactant and
product species. Thus, reactions generated by thermodynamic rules do not
always have the same reaction rate. In contrast, all reactions generated
by a single non-thermodynamic rule will have the same reaction rate,
unless a local function is used for rate specification.

In the following we will specify the dimerization of RAF molecules. For
this purpose, we introduce three parameters: the activation energy for
the binding reaction \(E_a\) (Ea suffix), the Gibb's free energy of the
formed bond \(\Delta G\) (dG suffix), and the thermodynamic balance
parameter \(\phi\) (phi suffix).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}Ea}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}dG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}phi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    To enforce that the activation energy \(E_a = - \log(k_f)\) encodes the
forward reaction rate and
\(\Delta G = - \log(K) = -\log \left(\frac{k_r}{k_f}\right)\) encodes
the affinity constant \(K\), we will pass a specially crafted custom
activation energy \(E_{a0} = - \phi \Delta G - E_a\), for which we
create a custom expression. To then construct homo- and
heterodimerization rules for all RAF paralogs, we use \texttt{itertools}
to loop over all combinations of BRAF and CRAF, implementing equal
affinities for all homo- and heterodimers. For every rule we pass the
custom energy \(Ea_0\) and then specify an \texttt{EnergyPattern} for
the single product pattern (\texttt{pp}) with
\(\Delta \Delta G_p = \Delta G\).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pysb} \PY{k+kn}{import} \PY{n}{Rule}\PY{p}{,} \PY{n}{EnergyPattern}
\PY{k+kn}{import} \PY{n+nn}{itertools} \PY{k}{as} \PY{n+nn}{itt}

\PY{n}{Expression}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Ea0\PYZus{}bind\PYZus{}RAF\PYZus{}RAF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
           \PY{o}{\PYZhy{}}\PY{n}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}phi}\PY{o}{*}\PY{n}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}dG} \PY{o}{\PYZhy{}} \PY{n}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}Ea}\PY{p}{)}\PY{p}{;}

\PY{k}{for} \PY{n}{RAF1}\PY{p}{,} \PY{n}{RAF2} \PY{o+ow}{in} \PY{n}{itt}\PY{o}{.}\PY{n}{combinations\PYZus{}with\PYZus{}replacement}\PY{p}{(}\PY{p}{[}\PY{n}{BRAF}\PY{p}{,} \PY{n}{CRAF}\PY{p}{]}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{:}
    \PY{n}{pp} \PY{o}{=} \PY{n}{RAF1}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAF2}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
    \PY{n}{Rule}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF1}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}and\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF2}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}bind\PYZus{}and\PYZus{}dissociate}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
         \PY{n}{RAF1}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)} \PY{o}{+} \PY{n}{RAF2}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)} \PY{o}{|} \PY{n}{pp}\PY{p}{,} 
         \PY{n}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}phi}\PY{p}{,} \PY{n}{Ea0\PYZus{}bind\PYZus{}RAF\PYZus{}RAF}\PY{p}{,} \PY{n}{energy}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
    \PY{n}{EnergyPattern}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}bind\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF1}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF2}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{pp}\PY{p}{,} \PY{n}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}dG}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{raf-inhibitor}{%
\subsection{RAF inhibitor}\label{raf-inhibitor}}

Next, we introduce a RAF inhibitor RAFi. We assume that the inhibitor is
added to the cell medium at some point and quickly diffuses in and out
of cells. As extracellular space is much bigger than the volume of a
cell, we can assume an infinite reservoir of molecules in the
extracellular compartment and assume that the intracellular inhibitors
concentration will be unaffected by intracellular reactions.
Accordingly, we specify the respective initial as fixed, which means
that the respective molecular species can participate in reactions, but
its concentration will remain constant.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Monomer}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RAFi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{raf}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}

\PY{n}{Initial}\PY{p}{(}\PY{n}{RAFi}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)}\PY{p}{,} \PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RAFi\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mf}{0.0}\PY{p}{)}\PY{p}{,} \PY{n}{fixed}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    Next, we define binding reactions for RAFi with both BRAF and CRAF,
again implementing the same affinities and activation energies for both
rules.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}Ea}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}dG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}phi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{Expression}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Ea0\PYZus{}bind\PYZus{}RAFi\PYZus{}RAF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
           \PY{o}{\PYZhy{}}\PY{n}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}phi}\PY{o}{*}\PY{n}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}dG} \PY{o}{\PYZhy{}} \PY{n}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}Ea}\PY{p}{)}

\PY{k}{for} \PY{n}{RAF} \PY{o+ow}{in} \PY{p}{[}\PY{n}{BRAF}\PY{p}{,} \PY{n}{CRAF}\PY{p}{]}\PY{p}{:}
    \PY{n}{Rule}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RAFi\PYZus{}and\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}bind\PYZus{}and\PYZus{}dissociate}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
         \PY{n}{RAFi}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)} \PY{o}{+} \PY{n}{RAF}\PY{p}{(}\PY{n}{rafi}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)} \PY{o}{|} \PY{n}{RAFi}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAF}\PY{p}{(}\PY{n}{rafi}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,} 
         \PY{n}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}phi}\PY{p}{,} \PY{n}{Ea0\PYZus{}bind\PYZus{}RAFi\PYZus{}RAF}\PY{p}{,} \PY{n}{energy}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
    \PY{n}{EnergyPattern}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}bind\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}RAFi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
                  \PY{n}{RAFi}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAF}\PY{p}{(}\PY{n}{rafi}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,} \PY{n}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}dG}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{paradoxical-activation}{%
\subsection{Paradoxical Activation}\label{paradoxical-activation}}

RAF inhibitors inhibit signaling for BRAF mutant cancer cells but
promote signaling for RAS mutant cancer cells. At the structural level,
this can be rationalized by assuming that RAF inhibitors have higher
affinity towards drug-unbound RAF dimers and lower affinity towards drug
bound RAF dimers. The symmetry conveyed by energy conservation of
molecular binding reactions implies that RAF inhibitors, promote
dimerization at low to medium concentrations and incompletely inhibit
signaling even at high concentrations, as they have lower affinity to
the second protomer in a RAF dimer. As MAPK signaling for RAS mutant
cells is mediated by RAF dimers, respective signaling is amplified,
leading to increased growth. In the thermodynamic models, this can be
implemented by specifying additional \texttt{EnergyPattern}s that
controls the Gibbs free energy of \(\mathrm{RAF}_2-\mathrm{RAFi}\)
trimers. Note that we do not specify how these trimers are formed, so
the change in energy will equally apply to the rates of all reactions
that either consume or produce these trimers. In this example, an
decrease in energy would equally increase RAF dimerization when exactly
one protomer is inhibitor bound and inhibitor binding to the first
protomer in a dimer, thereby implementing the previously described
symmetry.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}RAFi\PYZus{}ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{k}{for} \PY{n}{RAF1}\PY{p}{,} \PY{n}{RAF2} \PY{o+ow}{in} \PY{n}{itt}\PY{o}{.}\PY{n}{product}\PY{p}{(}\PY{p}{[}\PY{n}{BRAF}\PY{p}{,} \PY{n}{CRAF}\PY{p}{]}\PY{p}{,} \PY{n}{repeat}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{:}
    \PY{n}{EnergyPattern}\PY{p}{(}
        \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF1}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF2}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}mod\PYZus{}RAFi\PYZus{}single}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
        \PY{n}{RAF1}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{rafi}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAF2}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{rafi}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAFi}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{,} 
        \PY{n}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}RAFi\PYZus{}ddG}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    To implement the lower affinity to the second protomer, we add an
additional \texttt{EnergyPattern} that changes the Gibbs free energy of
\(\mathrm{RAF}_2-\mathrm{RAFi}_2\) tetramers.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}RAFi\PYZus{}RAFi\PYZus{}ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{k}{for} \PY{n}{RAF1}\PY{p}{,} \PY{n}{RAF2} \PY{o+ow}{in} \PY{n}{itt}\PY{o}{.}\PY{n}{combinations\PYZus{}with\PYZus{}replacement}\PY{p}{(}\PY{p}{[}\PY{n}{BRAF}\PY{p}{,} \PY{n}{CRAF}\PY{p}{]}\PY{p}{,} \PY{n}{r}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{:}
    \PY{n}{EnergyPattern}\PY{p}{(}
        \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF1}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF2}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}mod\PYZus{}RAFi\PYZus{}double}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
        \PY{n}{RAFi}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAF1}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{rafi}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAF2}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{rafi}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAFi}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,} 
        \PY{n}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}RAFi\PYZus{}RAFi\PYZus{}ddG}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    Here we note that these \texttt{EnergyPattern}s only specify that
changes in affinity are permissible in the model. The nature of these
changes has to be encoded in their values, where negative values lead to
stabilization and positive values to destabilization of respective
complexes.

\begin{figure}[!h]
\centering
\adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{model_schematic.eps}

\caption{Pre-calibration fit. Different rows correspond to different RAF inhibitors (vemurafenib and dabrafenib). Different columns correspond to different observables (pMEK and pERK). Colors indicate different experimental conditions (with and without EGF stimulation). Data is shown as dashed lines, simulations as solid lines.}
\label{fig:model}
\end{figure}

    This wraps up the description of RAF/RAF inhibitor interactions (Fig.~\ref{fig:model}) and 
we will now load the remainder of the model from a file. Briefly, the
full model describes MEK and ERK phosphorylation downstream as well as
EGF stimulatable EGFR signaling upstream of RAF signaling. Moreover, it
incorporates negative feedback from ERK on both MAPK and EGFR signaling.
A comprehensive description of this part of the model is available in
~\cite{2754712/I4JQ4DMV} and~\cite{2754712/Y3E9IYH8}. However, parts of
the model were substantially simplified account for the reduced set of
experimental data considered in this protocol. Specifically, description
of EGFR signaling is removed and replaced by a phenomenological
description, MEK inhibitors were removed from the model and two-step
phosphorylation and dephosphorylation reactions were replaced by linear
one-step reactions.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pysb} \PY{k+kn}{import} \PY{n}{Observable}\PY{p}{,} \PY{n}{ANY}
\PY{k}{def} \PY{n+nf}{extend\PYZus{}model}\PY{p}{(}\PY{p}{)}\PY{p}{:}
   Content of this function is only included in the interactive notebook.

\PY{n}{extend\PYZus{}model}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{importing-data-in-petab-format}{%
\section{Importing data in PEtab
Format}\label{importing-data-in-petab-format}}

    With the model at hand, the next step for model calibration is
specification of the objective function \(\eqref{eq:objective}\). We
will specify the objective function using PEtab~\cite{2754712/86CV69R2},
which simplifies the definition of multiple experimental conditions.
PEtab specification of a calibration problem consists of the tables
describing model observables, experimental measurements, experimental
conditions and model parameters. Additionally, tables describing the
visualization of simulations and data may also be included.

    \hypertarget{observables}{%
\subsection{Observables}\label{observables}}

We will start the PEtab definition by specifying the model observables
\(\textbf{y}\) (see \(\eqref{eq:observable}\)). Observables define the
the model quantities that were measured experimentally, here pMEK and
pERK. First, we add respective observables to the model using PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Observable}{\texttt{Observable}}s:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{11}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Observable}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pMEK\PYZus{}obs}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{MEK}\PY{p}{(}\PY{n}{phospho}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{p}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
\PY{n}{Observable}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pERK\PYZus{}obs}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{ERK}\PY{p}{(}\PY{n}{phospho}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{p}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    These observables quantify all MEK (MAP2K1 + MAP2K2) and ERK (MAPK1 +
MAPK3) molecules that are phosphorylated on the site \texttt{phospho},
which accounts for phosphorylation on S218/S222 or S222/S226 on MEK and
T185/Y187 or T202/Y204 on ERK. These PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Observable}{\texttt{Observable}}s
define linear sums of model species \(\sum_i w_i x_i\), where \(w_i\) is
an integer that quantifies how often the specified pattern matches the
species \(x_i\).

Next, we construct the PEtab
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#observables-table}{\texttt{observables\ table}}.
The model quantifies pMEK and pERK in concentrations, but measurements
are noise corrupted, measured in fluorescence intensity and also include
background fluorescence. As the scaling between concentrations and
intensity and the amount of background signal is unknown, we include
scaling and offset parameters in the PEtab observable definition
\texttt{petab.OBSERVABLE\_FORMULA}, which specifies the observable
function \(g_i\) (see \(\eqref{eq:observable}\)). To account for noise
corruption, we specify a single noise parameter \(\psi_i\) as PEtab
noise formula \texttt{petab.NOISE\_FORMULA}, which corresponds to a
Gaussian distribution (default when no
\texttt{petab.NOISE\_DISTRIBUTION} is specified), with the respective
parameter as standard deviation \(\sigma_i\) (see \(\eqref{eq:noise}\)).
The prefix \texttt{noiseParameter1} indicates that the value of the
parameter will be provided in the respective column of the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#measurement-table}{\texttt{measurement\ table}},
which permits the specification of time point and condition specific
noise levels via \(\Psi_{ijk}\) (see \(\eqref{eq:objective}\)). Here,
the specified observable formula \(g_i\) does not include any explicit
PEtab noise parameters. However, the scale and offset parameters for
each observable could be replaced by
\texttt{observableParameter{[}0-9{]}+} placeholders, which would enable
the designation of time point and condition specific values in the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#measurement-table}{\texttt{measurement\ table}}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{12}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{petab}
\PY{k+kn}{import} \PY{n+nn}{pandas} \PY{k}{as} \PY{n+nn}{pd}
\PY{n}{observables\PYZus{}table} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{[}
    \PY{p}{\PYZob{}}
        \PY{n}{petab}\PY{o}{.}\PY{n}{OBSERVABLE\PYZus{}ID}\PY{p}{:} \PY{n}{obs\PYZus{}id}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{OBSERVABLE\PYZus{}FORMULA}\PY{p}{:} 
            \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{obs\PYZus{}id}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}scale*}\PY{l+s+si}{\PYZob{}}\PY{n}{obs\PYZus{}id}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}obs + }\PY{l+s+si}{\PYZob{}}\PY{n}{obs\PYZus{}id}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}offset}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{NOISE\PYZus{}FORMULA}\PY{p}{:} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{noiseParameter1\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{obs\PYZus{}id}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}
    \PY{p}{\PYZcb{}} \PY{k}{for} \PY{n}{obs\PYZus{}id} \PY{o+ow}{in} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pMEK}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pERK}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
\PY{p}{]}\PY{p}{)}\PY{o}{.}\PY{n}{set\PYZus{}index}\PY{p}{(}\PY{n}{petab}\PY{o}{.}\PY{n}{OBSERVABLE\PYZus{}ID}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{measurements-and-conditions}{%
\subsection{Measurements and
Conditions}\label{measurements-and-conditions}}

As experimental measurements, we will load one of the datasets from
~\cite{2754712/I4JQ4DMV}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{13}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{synapseclient} \PY{k}{as} \PY{n+nn}{sc}
\PY{n}{pd}\PY{o}{.}\PY{n}{set\PYZus{}option}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{display.max\PYZus{}rows}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}
\PY{n}{pd}\PY{o}{.}\PY{n}{set\PYZus{}option}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{display.max\PYZus{}columns}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}

\PY{n}{syn} \PY{o}{=} \PY{n}{sc}\PY{o}{.}\PY{n}{Synapse}\PY{p}{(}\PY{p}{)}
\PY{n}{syn}\PY{o}{.}\PY{n}{login}\PY{p}{(}\PY{n}{silent}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}\PY{p}{;}
\PY{n}{data\PYZus{}df} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{read\PYZus{}csv}\PY{p}{(}\PY{n}{syn}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{syn22804081}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{path}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    The data contains the dose response to multiple RAF and MEK inhibitors
as well as respective combinations. However, to minimize computation
time requirements, we will only consider data involving the two RAFis
vemurafenib and dabrafenib. The model itself only contains generic
\texttt{RAFi} parameters and species, which we can now map to specific
inhibitors using experimental conditions. This permits the simultaneous
estimation of inhibitor specific kinetic rates in conjunction with all
other model parameters. Such a multi-experiment setup can improve
parameter identifiability.

In the following, we will simulatenously generate the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#condition-table}{\texttt{condition\ table}},
encoding the condition specific mapping \(\boldsymbol{\Gamma}_k\) (see
\(\eqref{eq:objective}\)) of dynamic paramers \(\boldsymbol{\gamma}\)
(see \(\eqref{eq:ode}\)), and
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#measurement-table}{\texttt{measurement\ table}},
ecoding measurements \(\bar{\textbf{y}} _{ijk}\) and, potentially,
respective mappings for observable parameters \(\boldsymbol{\xi}\) (see
\(\eqref{eq:observable}\)) via \(\boldsymbol{\Xi}_{ijk}\) (see
\(\eqref{eq:objective}\)) and noise parameters \(\boldsymbol{\psi}\)
(see \(\eqref{eq:noise}\)) via \(\boldsymbol{\Psi}_{ijk}\) (see
\(\eqref{eq:objective}\)). The
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#condition-table}{\texttt{condition\ table}}
describes the necessary information about experimentel conditions, i.e.,
what drug was used and what concentrations were applied. The
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#measurement-table}{\texttt{measurement\ table}}
describes the measurement itself as well as additional information, such
as under which experimental conditions the data was measured.

The data we loaded above is in a matrix format, but PEtab requires the
data in a long format. Thus, additional processing is necessary.
Briefly, the code below extracts all data points and sets what model
observable \texttt{petab.OBSERVABLE\_ID} they belong to, the value of
the measurement \texttt{petab.MEASUREMENT}, the time of measurement
\texttt{petab.TIME}, the noise parameter
\texttt{petab.NOISE\_PARAMETERS} and information about the experimental
condition.

For the EGF stimulation condition, it is important to consider the
experimental setup, as cells are subjected to 24h of pretreatment with
drugs. We here assume that this is sufficient time for the system to
reach a steady state. To describe such an experimental setup in PEtab,
it is necessary to reference the respective experimental condition in
the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#condition-table}{\texttt{condition\ table}}
by specifying the respective \texttt{petab.CONDITION\_ID} in the
\texttt{petab.PREEQUILIBRATION\_CONDITION\_ID} column. The condition for
the actual experiment can then be specified in the
\texttt{petab.SIMULATION\_CONDITION\_ID}.

To enable the visualization of data and fitting results, we here also
specify the \texttt{petab.DATASET\_ID}. This does not influence the
actual fitting, but serves as grouping identifier during visualization.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{14}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{RAFis} \PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Vemurafenib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Dabrafenib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{PLX8394}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{LY3009120}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{AZ\PYZus{}628}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
\PY{n}{MEKis} \PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Cobimetinib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Trametinib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Selumetinib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Binimetinib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{PD0325901}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}


\PY{n}{conditions} \PY{o}{=} \PY{n+nb}{dict}\PY{p}{(}\PY{p}{)}


\PY{k}{def} \PY{n+nf}{format\PYZus{}petab}\PY{p}{(}\PY{n}{row}\PY{p}{)}\PY{p}{:}
    \PY{n}{suffixes} \PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{+} \PY{p}{[}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{.}\PY{l+s+si}{\PYZob{}}\PY{n}{idx}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}} \PY{k}{for} \PY{n}{idx} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{]}
    \PY{n}{datapoints} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{k}{if} \PY{n}{row}\PY{p}{[}\PY{n}{MEKis}\PY{p}{]}\PY{o}{.}\PY{n}{any}\PY{p}{(}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n}{datapoints}
    \PY{c+c1}{\PYZsh{} loop over columns of the data matrix}
    \PY{k}{for} \PY{n}{suffix} \PY{o+ow}{in} \PY{n}{suffixes}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} extract data}
        \PY{n}{datapoint} \PY{o}{=} \PY{p}{\PYZob{}}
            \PY{n}{petab}\PY{o}{.}\PY{n}{OBSERVABLE\PYZus{}ID}\PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pMEK}\PY{l+s+s1}{\PYZsq{}} \PY{k}{if} \PY{n}{row}\PY{o}{.}\PY{n}{pMEK} \PY{k}{else} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pERK}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
            \PY{n}{petab}\PY{o}{.}\PY{n}{MEASUREMENT}\PY{p}{:} \PY{n}{row}\PY{p}{[}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Mean}\PY{l+s+si}{\PYZob{}}\PY{n}{suffix}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
            \PY{n}{petab}\PY{o}{.}\PY{n}{TIME}\PY{p}{:} \PY{n}{row}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Time\PYZus{}EGF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
            \PY{n}{petab}\PY{o}{.}\PY{n}{NOISE\PYZus{}PARAMETERS}\PY{p}{:} \PY{n}{row}\PY{p}{[}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Std}\PY{l+s+si}{\PYZob{}}\PY{n}{suffix}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
        \PY{p}{\PYZcb{}}
        \PY{c+c1}{\PYZsh{} extract condition information}
        \PY{k}{if} \PY{p}{(}\PY{n}{row}\PY{p}{[}\PY{n}{RAFis}\PY{p}{]} \PY{o}{!=} \PY{l+m+mi}{0}\PY{p}{)}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{p}{)} \PY{o}{!=} \PY{l+m+mi}{1} \PY{o+ow}{or} \PYZbs{}
                \PY{p}{(}\PY{p}{(}\PY{n}{row}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Vemurafenib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{)} \PY{o+ow}{and} \PY{p}{(}\PY{n}{row}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Dabrafenib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{)}\PY{p}{)}\PY{p}{:}
            \PY{k}{continue}

        \PY{c+c1}{\PYZsh{} find first nonzero}
        \PY{n}{rafi} \PY{o}{=} \PY{n}{RAFis}\PY{p}{[}\PY{p}{(}\PY{n}{row}\PY{p}{[}\PY{n}{RAFis}\PY{p}{]} \PY{o}{!=} \PY{l+m+mi}{0}\PY{p}{)}\PY{o}{.}\PY{n}{argmax}\PY{p}{(}\PY{p}{)}\PY{p}{]}

        \PY{c+c1}{\PYZsh{} extract drug concentration}
        \PY{n}{drug\PYZus{}conc} \PY{o}{=} \PY{n}{row}\PY{p}{[}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Concentration (uM)}\PY{l+s+si}{\PYZob{}}\PY{n}{suffix}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{k}{if} \PY{n}{row}\PY{p}{[}\PY{n}{rafi}\PY{p}{]} \PY{o}{==} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1} \PYZbs{}
            \PY{k}{else} \PY{n}{row}\PY{p}{[}\PY{n}{rafi}\PY{p}{]}
        \PY{c+c1}{\PYZsh{} condition id must be sanitzed, must match \PYZsq{}\PYZca{}[a\PYZhy{}zA\PYZhy{}Z]+[\PYZbs{}w\PYZus{}]*\PYZdl{}\PYZsq{}}
        \PY{n}{drug\PYZus{}str} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{rafi}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{drug\PYZus{}conc}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{.}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZhy{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

        \PY{n}{condition\PYZus{}str} \PY{o}{=} \PY{n}{drug\PYZus{}str} \PY{o}{+} \PY{p}{(}
            \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}EGF\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{row}\PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{EGF}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}} \PY{k}{if} \PY{n}{row}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{EGF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0} \PY{k}{else} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}
        \PY{p}{)}
        \PY{n}{condition} \PY{o}{=} \PY{p}{\PYZob{}}
            \PY{n}{petab}\PY{o}{.}\PY{n}{CONDITION\PYZus{}ID}\PY{p}{:} \PY{n}{condition\PYZus{}str}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RAFi\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{drug\PYZus{}conc}\PY{p}{,}
            \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{EGF\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{row}\PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{EGF}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}Ea}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{rafi}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}RAF\PYZus{}Ea}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
            \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}dG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{rafi}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}RAF\PYZus{}dG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
            \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}RAFi\PYZus{}ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{rafi}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
            \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}RAFi\PYZus{}RAFi\PYZus{}ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{rafi}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{rafi}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}ddG}\PY{l+s+s1}{\PYZsq{}}
        \PY{p}{\PYZcb{}}
        \PY{c+c1}{\PYZsh{} set baseline for datapoint}
        \PY{n}{datapoint}\PY{p}{[}\PY{n}{petab}\PY{o}{.}\PY{n}{PREEQUILIBRATION\PYZus{}CONDITION\PYZus{}ID}\PY{p}{]} \PY{o}{=} \PY{n}{drug\PYZus{}str}
        \PY{c+c1}{\PYZsh{} set id for condition and datapoint}
        \PY{n}{datapoint}\PY{p}{[}\PY{n}{petab}\PY{o}{.}\PY{n}{SIMULATION\PYZus{}CONDITION\PYZus{}ID}\PY{p}{]} \PY{o}{=} \PY{n}{condition\PYZus{}str}
        \PY{n}{datapoint}\PY{p}{[}\PY{n}{petab}\PY{o}{.}\PY{n}{DATASET\PYZus{}ID}\PY{p}{]} \PY{o}{=}  \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{EGF\PYZus{}\PYZus{}}\PY{l+s+s1}{\PYZsq{}} \PY{k}{if} \PY{n}{row}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{EGF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0} \PYZbs{}
                                        \PY{k}{else} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ctrl\PYZus{}\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{rafi}
        \PY{n}{condition}\PY{p}{[}\PY{n}{petab}\PY{o}{.}\PY{n}{CONDITION\PYZus{}ID}\PY{p}{]} \PY{o}{=} \PY{n}{condition\PYZus{}str}
        
        \PY{n}{datapoints}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{datapoint}\PY{p}{)}
        \PY{k}{if} \PY{n}{condition\PYZus{}str} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{conditions}\PY{p}{:}
            \PY{n}{conditions}\PY{p}{[}\PY{n}{condition\PYZus{}str}\PY{p}{]} \PY{o}{=} \PY{n}{condition}
            
    \PY{k}{return} \PY{n}{datapoints}

\PY{n}{measurement\PYZus{}table} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{[}
    \PY{n}{d}
    \PY{k}{for} \PY{n}{ir}\PY{p}{,} \PY{n}{row} \PY{o+ow}{in} \PY{n}{data\PYZus{}df}\PY{o}{.}\PY{n}{iterrows}\PY{p}{(}\PY{p}{)}
    \PY{k}{for} \PY{n}{d} \PY{o+ow}{in} \PY{n}{format\PYZus{}petab}\PY{p}{(}\PY{n}{row}\PY{p}{)}
\PY{p}{]}\PY{p}{)}
\PY{n}{condition\PYZus{}table} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{n}{conditions}\PY{o}{.}\PY{n}{values}\PY{p}{(}\PY{p}{)}\PY{p}{)}\PY{o}{.}\PY{n}{set\PYZus{}index}\PY{p}{(}\PY{n}{petab}\PY{o}{.}\PY{n}{CONDITION\PYZus{}ID}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    In the code above, we extracted experimentally measured standard
deviations, which can be noisy as they are often computed from a small
number of biological or technical replicates. As the magnitude of
standard deviations determines the importance of datapoints during
calibration, outliers can lead to overemphasis or ignorance of
individual datapoints, resulting in poor fits to the overall data. To
avoid such issues, we use the same averaged standard deviations for all
datapoints of each observable. For averaging we compute the root mean
square, as variances are additive, but standard deviations are not.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{15}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{k}{for} \PY{n}{group}\PY{p}{,} \PY{n}{frame} \PY{o+ow}{in} \PY{n}{measurement\PYZus{}table}\PY{o}{.}\PY{n}{groupby}\PY{p}{(}\PY{n}{petab}\PY{o}{.}\PY{n}{OBSERVABLE\PYZus{}ID}\PY{p}{)}\PY{p}{:}
    \PY{n}{measurement\PYZus{}table}\PY{o}{.}\PY{n}{loc}\PY{p}{[}\PY{n}{measurement\PYZus{}table}\PY{p}{[}\PY{n}{petab}\PY{o}{.}\PY{n}{OBSERVABLE\PYZus{}ID}\PY{p}{]}\PY{o}{==}\PY{n}{group}\PY{p}{,} 
                          \PY{n}{petab}\PY{o}{.}\PY{n}{NOISE\PYZus{}PARAMETERS}\PY{p}{]} \PY{o}{=} \PYZbs{}
        \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{frame}\PY{p}{[}\PY{n}{petab}\PY{o}{.}\PY{n}{NOISE\PYZus{}PARAMETERS}\PY{p}{]}\PY{o}{.}\PY{n}{apply}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{square}\PY{p}{)}\PY{o}{.}\PY{n}{mean}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\PY{n}{measurement\PYZus{}table}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{parameters}{%
\subsection{Parameters}\label{parameters}}

The last table necessary for model training is the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#parameter-table}{\texttt{parameter\ table}}.
This table describes all free parameters \(\boldsymbol{\theta}\)
(\texttt{petab.PARAMETER\_ID}), whether they have to be estimated
(\texttt{petab.ESTIMATE}) as well as their scales
(\texttt{petab.PARAMETER\_SCALE}), nominal values
(\texttt{petab.NOMINAL\_VALUE}), boundary values \(\mathcal{L}_l\)
(\texttt{petab.LOWER\_BOUND}) and \(\mathcal{U}_l\)
(\texttt{petab.UPPER\_BOUND}) and information about priors.

Both parameter boundaries and priors can be used to restrict the search
space to biologically plausible parameter values, or prevent numerical
issues in regions of parameter space where numerical integration of
model equations is challenging. Parameter boundaries set hard thresholds
that cannot be exceeded, while parameter priors are soft constraints
that also regularize the calibration. While priors are necessary for
Bayesian analysis such as parameter sampling, they are not generally
required for optimization based approaches.

For most models, free parameters \(\boldsymbol{\theta}\) will primarily
occur in the model specification as dynamic parameters
\(\boldsymbol{\gamma}\). But, all of previously described tables may
introduce new free parameters: noise parameters \(\boldsymbol{\psi}\) in
noise formulas \(\boldsymbol{\sigma}\) or respective condition specific
mappings \(\boldsymbol{\Psi}_{ijk}\), observable paramers
\(\boldsymbol{\xi}\) in observable formulas \(\boldsymbol{g}\) or
respective condition specific mappings \(\boldsymbol{\Xi}_{ijk}\) as
well as the condition specific dynamic parameter mappings
\(\boldsymbol{\Gamma}_{k}\). Moreover, the respective tables, i.e., the
respective mappings \(\boldsymbol{\Psi}_{ijk}\),
\(\boldsymbol{\Xi}_{ijk}\) and \(\boldsymbol{\Gamma}_{k}\) may set
numerical values for the noise, observable and dynamic parameters,
rendering them non-free. As the parameter table must only describe free
parameters \(\boldsymbol{\theta}\), some processing is usually necessary
to identify free and non-free parameters.

In the following, we will construct a list of \texttt{condition\_pars},
which are either mapped to free, condition-specific parameters, such as
the generic RAFi energy parameters, or set to non-free parameters with
fixed numeric values, such as the \texttt{RAFi\_0} initial
concentration. To construct the list of free parameters, we identify all
dynamic parameters in the model that are not contained in these
\texttt{condition\_pars}, and add all newly introduced condition
specific parameters in the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#condition-table}{\texttt{condition\ table}}
as well as the four offset and scaling parameters we introduced in the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#observables-table}{\texttt{observables\ table}}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{16}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{n}{condition\PYZus{}pars} \PY{o}{=} \PY{p}{[}
    \PY{n}{par}\PY{o}{.}\PY{n}{name}
    \PY{k}{for} \PY{n}{par} \PY{o+ow}{in} \PY{n}{model}\PY{o}{.}\PY{n}{parameters}
    \PY{k}{if} \PY{n}{par}\PY{o}{.}\PY{n}{name} \PY{o+ow}{in} \PY{n}{condition\PYZus{}table}\PY{o}{.}\PY{n}{columns}
\PY{p}{]}

\PY{n}{free\PYZus{}parameters} \PY{o}{=} \PY{p}{[}
    \PY{n}{par}\PY{o}{.}\PY{n}{name} \PY{k}{for} \PY{n}{par} \PY{o+ow}{in} \PY{n}{model}\PY{o}{.}\PY{n}{parameters}
    \PY{k}{if} \PY{n}{par}\PY{o}{.}\PY{n}{name} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{condition\PYZus{}pars}
\PY{p}{]} \PY{o}{+} \PY{p}{[}
    \PY{n}{name}
    \PY{k}{for} \PY{n}{par} \PY{o+ow}{in} \PY{n}{condition\PYZus{}pars}
    \PY{k}{for} \PY{n}{name} \PY{o+ow}{in} \PY{n}{np}\PY{o}{.}\PY{n}{unique}\PY{p}{(}\PY{n}{condition\PYZus{}table}\PY{p}{[}\PY{n}{par}\PY{p}{]}\PY{p}{)}
    \PY{k}{if} \PY{n+nb}{isinstance}\PY{p}{(}\PY{n}{name}\PY{p}{,} \PY{n+nb}{str}\PY{p}{)}
\PY{p}{]} \PY{o}{+} \PY{p}{[}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pMEK\PYZus{}offset}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pMEK\PYZus{}scale}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pERK\PYZus{}offset}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pERK\PYZus{}scale}\PY{l+s+s1}{\PYZsq{}}
\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

    All of the parameters in the model follow a consistent naming scheme,
which makes it easier to programmatically specify parameter boundaries,
scales and whether parameters are to be estimated. Multiple studies have
demonstrated that parameter estimation is more efficient when estimating
parameters on a logarithmic scale
~\cite{2754712/INKV577L,2754712/FMD3RVCR}. Yet, the thermodynamic
formulation we employed for model construction relies on an exponential
dependency between energies and kinetic rates, which complements these
practical insights with a theoretical foundation why a logarithmic scale
is more natural. However, this also suggests that energetic parameters,
in contrast to kinetic rates, should be estimated on a linear scale.

The upper and lower boundaries should ideally be set to biologically
plausible values. However, most models employ simplified descriptions of
the underlying biochemical processes, which means that model parameters
may no longer have a one-to-one correspondence to true biochemical
constants and plausible parameter ranges may be difficult to derive.
Moreover, plausible parameter ranges may not be known for all
parameters. Therefore, in many applications parameter boundaries are
initially based on educated guesses and then refined based on estimation
results such that optima are contained in the specified ranges and
integration failures are not too frequent. Therefore, the boundaries
presented here are based on the values used in the original publication
~\cite{2754712/I4JQ4DMV} and were then refined to work with the
simplified model.

Similar to parameter boundaries, nominal values can be difficult to
derive. However, the numerical values are only important for model
calibration when respective parameters are not estimated. In this
example, we do not estimate the initial concentrations and \(\phi\)
parameters and only set the nominal parameter values of those parameters
to non-trivial values. The initial concentrations are set to approximate
molecular counts as measured in the original publication and \(\phi\)
parameters are all set to 1, meaning that free energy differences only
affect the reverse rate.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{17}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{lbs} \PY{o}{=} \PY{p}{\PYZob{}}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Ea}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{o}{\PYZhy{}}\PY{l+m+mi}{8}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{dG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{o}{\PYZhy{}}\PY{l+m+mi}{8}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{o}{\PYZhy{}}\PY{l+m+mi}{8}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{phi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{offset}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{5e\PYZhy{}2}\PY{p}{,}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{scale}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e0}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{eq}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e1}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e3}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kcat}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e\PYZhy{}2}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{gexpslope}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e0}\PY{p}{,}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kdeg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e\PYZhy{}3}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kM}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e\PYZhy{}3}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kcatr}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e\PYZhy{}5}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{koff}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e\PYZhy{}5}\PY{p}{,}
\PY{p}{\PYZcb{}}
\PY{n}{ubs} \PY{o}{=} \PY{p}{\PYZob{}}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Ea}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{dG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{phi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{offset}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{2e\PYZhy{}1}\PY{p}{,}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{scale}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e6}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{eq}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e5}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e5}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kcat}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e5}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{gexpslope}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e6}\PY{p}{,}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kdeg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e2}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kM}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e1}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kcatr}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e2}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{koff}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e0}\PY{p}{,}
\PY{p}{\PYZcb{}}

\PY{n}{initials} \PY{o}{=} \PY{p}{\PYZob{}}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BRAF\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e3}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{CRAF\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e4}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{MEK\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e5}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ERK\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e5}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RAS\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{5e4}\PY{p}{,}
\PY{p}{\PYZcb{}}


\PY{n}{parameter\PYZus{}table} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{[}
    \PY{p}{\PYZob{}}
        \PY{n}{petab}\PY{o}{.}\PY{n}{PARAMETER\PYZus{}ID}\PY{p}{:} \PY{n}{par}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{PARAMETER\PYZus{}SCALE}\PY{p}{:} \PY{n}{petab}\PY{o}{.}\PY{n}{LIN} 
        \PY{k}{if} \PY{n}{par}\PY{o}{.}\PY{n}{endswith}\PY{p}{(}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}Ea}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}dG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}phi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)} \PY{k}{else} \PY{n}{petab}\PY{o}{.}\PY{n}{LOG10}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{LOWER\PYZus{}BOUND}\PY{p}{:} \PY{n}{lbs}\PY{p}{[}\PY{n}{par}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{UPPER\PYZus{}BOUND}\PY{p}{:} \PY{n}{ubs}\PY{p}{[}\PY{n}{par}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{NOMINAL\PYZus{}VALUE}\PY{p}{:} \PY{n}{initials}\PY{p}{[}\PY{n}{par}\PY{p}{]} \PY{k}{if} \PY{n}{par}\PY{o}{.}\PY{n}{endswith}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{k}{else} \PY{l+m+mf}{1.0}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{ESTIMATE}\PY{p}{:} \PY{k+kc}{False} \PY{k}{if} \PY{n}{par}\PY{o}{.}\PY{n}{endswith}\PY{p}{(}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}phi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)} \PY{k}{else} \PY{k+kc}{True}\PY{p}{,}
        
    \PY{p}{\PYZcb{}} \PY{k}{for} \PY{n}{par} \PY{o+ow}{in} \PY{n}{free\PYZus{}parameters}
\PY{p}{]}\PY{p}{)}\PY{o}{.}\PY{n}{set\PYZus{}index}\PY{p}{(}\PY{n}{petab}\PY{o}{.}\PY{n}{PARAMETER\PYZus{}ID}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{sbml-export}{%
\subsection{SBML export}\label{sbml-export}}

PEtab expects a model in SBML format (an extension allowing other
modeling formats is being developed at the time of writing), but we
constructed the model in the PySB/BNGL format. Therefore, we need to
export the model in SBML format.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{18}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{libsbml}
\PY{k+kn}{from} \PY{n+nn}{pysb}\PY{n+nn}{.}\PY{n+nn}{export} \PY{k+kn}{import} \PY{n}{export}
\PY{n}{sbml\PYZus{}reader} \PY{o}{=} \PY{n}{libsbml}\PY{o}{.}\PY{n}{SBMLReader}\PY{p}{(}\PY{p}{)}
\PY{n}{sbml\PYZus{}doc} \PY{o}{=} \PY{n}{sbml\PYZus{}reader}\PY{o}{.}\PY{n}{readSBMLFromString}\PY{p}{(}\PY{n}{export}\PY{p}{(}\PY{n}{model}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{sbml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
\PY{n}{sbml\PYZus{}model} \PY{o}{=} \PY{n}{sbml\PYZus{}doc}\PY{o}{.}\PY{n}{getModel}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    In the SBML model, PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Observable}{\texttt{Observable}}s
are exported as SBML
\href{http://model.caltech.edu/software/libsbml/5.18.0/docs/formatted/python-api/classlibsbml_1_1_parameter.html}{\texttt{Parameters}}
and
\href{http://model.caltech.edu/software/libsbml/5.18.0/docs/formatted/python-api/classlibsbml_1_1_assignment_rule.html}{\texttt{AssignmentRule}},
with programmatically generated identifiers that do not match the PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Observable}{\texttt{Observable}}
names. As we referenced these observable names when specifying the PEtab
observables, we have to change the SBML identifiers to match the PySB
names. These changes have to be applied to the SBML
\href{http://model.caltech.edu/software/libsbml/5.18.0/docs/formatted/python-api/classlibsbml_1_1_parameter.html}{\texttt{Parameter}}
as well as the SBML
\href{http://model.caltech.edu/software/libsbml/5.18.0/docs/formatted/python-api/classlibsbml_1_1_assignment_rule.html}{\texttt{AssignmentRule}}
that sets their value.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{19}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} rename pysb exported observables}
\PY{n}{sbml\PYZus{}model}\PY{o}{.}\PY{n}{getParameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}obs1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{setId}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pMEK\PYZus{}obs}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{sbml\PYZus{}model}\PY{o}{.}\PY{n}{getAssignmentRuleByVariable}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}obs1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{setVariable}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pMEK\PYZus{}obs}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{sbml\PYZus{}model}\PY{o}{.}\PY{n}{getParameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}obs2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{setId}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pERK\PYZus{}obs}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{sbml\PYZus{}model}\PY{o}{.}\PY{n}{getAssignmentRuleByVariable}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}obs2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{setVariable}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pERK\PYZus{}obs}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    As last step, we create a PEtab
\href{https://petab.readthedocs.io/projects/libpetab-python/en/latest/build/_autosummary/petab.problem.html\#petab.problem.Problem}{\texttt{Problem}}
using all of the previously constructed tables as well as the exported
SBML model. As problem construction was a lengthy, error-prone process,
we perform a static analysis of the PEtab problem using the PEtab
library provided linter
\href{https://petab.readthedocs.io/projects/libpetab-python/en/latest/build/_autosummary/petab.html\#petab.lint_problem}{\texttt{petab.lint\_problem}}.
Here we suppress any SBML warnings, as they are only due to the
implementation of the SBML export in PySB. These warnings cause the
linter to terminate with ``Not OK'', but as there are no further issues,
we can proceed with calibration.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{20}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{petab}
\PY{k+kn}{import} \PY{n+nn}{logging}
\PY{k+kn}{import} \PY{n+nn}{sys}
\PY{k+kn}{from} \PY{n+nn}{petab}\PY{n+nn}{.}\PY{n+nn}{models}\PY{n+nn}{.}\PY{n+nn}{sbml\PYZus{}model} \PY{k+kn}{import} \PY{n}{SbmlModel}

\PY{n}{petab\PYZus{}problem} \PY{o}{=} \PY{n}{petab}\PY{o}{.}\PY{n}{Problem}\PY{p}{(}
    \PY{n}{model}\PY{o}{=}\PY{n}{SbmlModel}\PY{p}{(}\PY{n}{sbml\PYZus{}model}\PY{o}{=}\PY{n}{sbml\PYZus{}model}\PY{p}{,} \PY{n}{sbml\PYZus{}reader}\PY{o}{=}\PY{n}{sbml\PYZus{}reader}\PY{p}{,} \PY{n}{sbml\PYZus{}document}\PY{o}{=}\PY{n}{sbml\PYZus{}doc}\PY{p}{)}\PY{p}{,}
    \PY{n}{measurement\PYZus{}df}\PY{o}{=}\PY{n}{measurement\PYZus{}table}\PY{p}{,} \PY{n}{condition\PYZus{}df}\PY{o}{=}\PY{n}{condition\PYZus{}table}\PY{p}{,}
    \PY{n}{observable\PYZus{}df}\PY{o}{=}\PY{n}{observables\PYZus{}table}\PY{p}{,} \PY{n}{parameter\PYZus{}df}\PY{o}{=}\PY{n}{parameter\PYZus{}table}
\PY{p}{)}
\PY{n}{petab}\PY{o}{.}\PY{n}{sbml}\PY{o}{.}\PY{n}{logger}\PY{o}{.}\PY{n}{setLevel}\PY{p}{(}\PY{n}{logging}\PY{o}{.}\PY{n}{ERROR}\PY{p}{)}
\PY{n}{petab}\PY{o}{.}\PY{n}{lint}\PY{o}{.}\PY{n}{logger}\PY{o}{.}\PY{n}{setLevel}\PY{p}{(}\PY{n}{logging}\PY{o}{.}\PY{n}{INFO}\PY{p}{)}
\PY{n}{petab}\PY{o}{.}\PY{n}{lint}\PY{o}{.}\PY{n}{logger}\PY{o}{.}\PY{n}{addHandler}\PY{p}{(}\PY{n}{logging}\PY{o}{.}\PY{n}{StreamHandler}\PY{p}{(}\PY{n}{sys}\PY{o}{.}\PY{n}{stdout}\PY{p}{)}\PY{p}{)}
\PY{n}{petab}\PY{o}{.}\PY{n}{lint\PYZus{}problem}\PY{p}{(}\PY{n}{petab\PYZus{}problem}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Checking model{\ldots}
Checking measurement table{\ldots}
Checking condition table{\ldots}
Checking observable table{\ldots}
Checking parameter table{\ldots}
Not OK
    \end{Verbatim}

    \hypertarget{calibrating-the-model-in-pypesto}{%
\section{Calibrating the model in
pyPESTO}\label{calibrating-the-model-in-pypesto}}

Model calibration based on PEtab~\cite{2754712/86CV69R2} format is
supported by a growing number of tools, including COPASI
~\cite{2754712/I9T5NNAF} and data2dynamics~\cite{2754712/RYRYBYZA}. Here
we used the python based calibration tool pyPESTO for calibration.
pyPESTO uses AMICI~\cite{2754712/HBAI2XHJ} for model import and
simulation, constructs functions to evaluate the objective function
\(J(\boldsymbol{\theta})\) and its gradient
\(\nabla_{\boldsymbol{\theta}}J(\boldsymbol{\theta})\) and provides an
interface to a plethora of different optimizers.

To facilitate efficient evaluation of the objective function and its
derivatives, we will first compile the model in AMICI. Model compilation
should take about a minute on modern desktop machines, but ensures that
numerical solutions \(\textbf{x}\) and their sensitivities
\(\nabla_{\boldsymbol{\gamma}}\textbf{x}\), which are required for the
evaluation of \(\nabla_{\boldsymbol{\theta}}J(\boldsymbol{\theta})\),
are computed using the SUNDIALS solver suite~\cite{2754712/YDMLXLFR}.
AMICI compilation is triggered by calling the
\href{https://pypesto.readthedocs.io/en/latest/api_petab.html\#pypesto.petab.PetabImporter.compile_model}{\texttt{compile\_model}}
method of a pyPESTO
\href{https://pypesto.readthedocs.io/en/latest/api_petab.html\#pypesto.petab.PetabImporter}{\texttt{PetabImporter}}
instance. The compiled model will be automatically used by other methods
of the same \texttt{PetabImporter} instance.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{21}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{pypesto}
\PY{k+kn}{import} \PY{n+nn}{pypesto}\PY{n+nn}{.}\PY{n+nn}{petab}
\PY{k+kn}{import} \PY{n+nn}{amici}

\PY{n}{importer} \PY{o}{=} \PY{n}{pypesto}\PY{o}{.}\PY{n}{petab}\PY{o}{.}\PY{n}{PetabImporter}\PY{p}{(}\PY{n}{petab\PYZus{}problem}\PY{p}{,}
                                       \PY{n}{model\PYZus{}name}\PY{o}{=}\PY{n}{model}\PY{o}{.}\PY{n}{name}\PY{p}{,}
                                       \PY{n}{validate\PYZus{}petab}\PY{o}{=}\PY{k+kc}{False}\PY{p}{)}

\PY{n}{importer}\PY{o}{.}\PY{n}{compile\PYZus{}model}\PY{p}{(}\PY{n}{verbose}\PY{o}{=}\PY{n}{logging}\PY{o}{.}\PY{n}{ERROR}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Simulations in AMICI are highly customizable and many steps, including
everything that was specified in the the PEtab problem, are automated by
pyPESTO. Yet, not all options are set automatically and some user input
may be required. For example, the considered example includes
preequilibrations (specified by
\texttt{petab.PREEQUILIBRATION\_CONDITION}), which are automatically
handled by pyPESTO and AMICI. However, AMICI supports multiple different
methods to compute steady states as well as respective sensitivities. By
default, a combination of Newton's method and simulation is employed to
approximate the steady state~\cite{2754712/LVNQBT95}. To find a steady
state by Newton's method, the Newton-Raphson algorithm is applied to the
rootfinding problem

\[ \{\textbf{x}: \textbf{f}(t,\textbf{x},\boldsymbol{\gamma}) = 0\}. \]

In contrast, the simulation based approach numerically integrates
\(\eqref{eq:ode}\) until \(\textbf{f}\) is sufficiently small with
respect to some norm. For both approaches, AMICI uses a convergence
criteria based on a combination of absolute and relative tolerances,
similar to error control during numerical integration:

\[ \sum_i^{\dims{x}} \frac{f_i(t,\textbf{x},\boldsymbol{\gamma})}{a + r x_i} < 1\]

where \(a\) and \(r\) are absolute and relative tolerances that can be
set via the
\href{https://amici.readthedocs.io/en/latest/generated/amici.amici.Solver.html\#amici.amici.Solver}{\texttt{Solver}}
methods
\href{https://amici.readthedocs.io/en/latest/generated/amici.amici.Solver.html\#amici.amici.Solver.setAbsoluteToleranceSteadyState}{\texttt{setAbsoluteToleranceSteadyState}}
and
\href{https://amici.readthedocs.io/en/latest/generated/amici.amici.Solver.html\#amici.amici.Solver.setRelativeToleranceSteadyState}{\texttt{setRelativeToleranceSteadyState}}
respectively. In both cases, sensitivites
\(\nabla_{\boldsymbol{\eta}}\textbf{x}_{ss}\) of the steady state
\(\textbf{x}_{ss}\) can be computed using the Implicit Function Theorem
(IFT)~\cite{2754712/6AWGLSM9}, which is the most efficient option when
applicable:

\[ \nabla_{\boldsymbol{\eta}}\textbf{x}_{ss} = \nabla_x\textbf{f}(t,\textbf{x}_{ss},\boldsymbol{\eta})^{-1}\nabla_{\boldsymbol{\eta}}\textbf{f}(t,\textbf{x}_{ss},\boldsymbol{\eta}) . \]

However, sensitivity computation via the IFT requires that the Jacobian
\(\nabla_x\textbf{f}(t,\textbf{x}_{ss},\boldsymbol{\gamma})\) is not
singular, which is, for example, not the case for models with
conservation laws. More details about preequilibration in AMICI is
available in the
\href{https://amici.readthedocs.io/en/latest/ExampleEquilibrationLogic.html}{\texttt{online\ documentation}}.

As the model we constructed does not account for protein synthesis and
degradation, total protein abundances are conserved quantities in the
model and the IFT is not applicable. Thus, we here employ a purely
simulation based steady state search by setting the allowed newton steps
to 0 and compute the steady state sensitivities using forward
sensitivity analysis by setting the steady state sensitivity mode
accordingly. To apply these options during optimization, we create AMICI
\href{https://amici.readthedocs.io/en/latest/generated/amici.amici.Solver.html\#amici.amici.Solver}{\texttt{Solver}}
and
\href{https://amici.readthedocs.io/en/latest/generated/amici.amici.Model.html\#amici.amici.Model}{\texttt{Model}}
instances from the \texttt{PetabImporter} and set respective options.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{22}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{amici}
\PY{n}{solver} \PY{o}{=} \PY{n}{importer}\PY{o}{.}\PY{n}{create\PYZus{}solver}\PY{p}{(}\PY{p}{)}
\PY{n}{model} \PY{o}{=} \PY{n}{importer}\PY{o}{.}\PY{n}{create\PYZus{}model}\PY{p}{(}\PY{p}{)}
\PY{n}{solver}\PY{o}{.}\PY{n}{setNewtonMaxSteps}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
\PY{n}{model}\PY{o}{.}\PY{n}{setSteadyStateSensitivityMode}\PY{p}{(}\PY{n}{amici}\PY{o}{.}\PY{n}{SteadyStateSensitivityMode}\PY{o}{.}\PY{n}{integrationOnly}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    AMICI also supports different sensitivity analysis methods for dynamic
simulations (specified by \texttt{petab.SIMULATION\_CONDITION\_ID})
~\cite{2754712/MKPQ9727}. For models with over 100 parameters, it usually
makes sense to use adjoint sensitivity analysis~\cite{2754712/INKV577L}.
However, for models that also require preequilibration, the computation
time of the simulation and gradient evaluation may be dominated by
preequilibration and the choice of sensitivity method for dynamic
simulations may have negligible impact on computation time. Accordingly,
other considerations, such as the availability of approximate second
order information should be taken into account when selecting the
sensitivity method. In contrast to forward sensitivity analysis, adjoint
sensitivity analysis does not provide an approximation to the Hessian of
the objective function~\cite{2754712/MKPQ9727}, rendering some
optimizers inapplicable and potentially reducing the convergence rate of
those that remain applicable. Therefore, we here chose forward
sensitivity analysis for dynamic simulations.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{23}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{solver}\PY{o}{.}\PY{n}{setSensitivityMethod}\PY{p}{(}\PY{n}{amici}\PY{o}{.}\PY{n}{SensitivityMethod}\PY{o}{.}\PY{n}{forward}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Another set of crucial parameters to tune are integration step limits
and tolerances. Lower tolerances generally improve accuracy of the
objective function and its derivatives, which influences local
convergence rate and success~\cite{2754712/9T4L23VZ,2754712/RUR9I9SQ}. However, lower
tolerances also increases the computation time~\cite{2754712/ICNACSXA},
so fewer optimization iterations could easily be offsetted by longer
compute times per iteration. Moreover, both integration tolerances and
step limits influence numerical integrability~\cite{2754712/ICNACSXA},
which can lead to complications during optimization. Low step limits can
promote numerical integration failure and, thereby, prevent optimization
from exploring difficult to integrate parameter regions. However, if
parameters from these regions yield good fits to the data, this can also
deteriorate or bias calibration. Accordingly, setting adequate values
for step limits and tolerances is integral for model calibration.
Nevertheless, there are little to no theoretical or practical guidelines
on how to choose adequate values. Ranges of \(10^{-8}\) to \(10^{-12}\)
are usually adequate~\cite{2754712/ICNACSXA}, but most of the time
values are chosen and updated empirically. Here we chose tolerances of
\(10^{-12}\) and a step limit of \(10^{5}\) integration steps, which is
rather conservative, but ensures adequate local convergence for the
considered problem.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{24}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{solver}\PY{o}{.}\PY{n}{setAbsoluteTolerance}\PY{p}{(}\PY{l+m+mf}{1e\PYZhy{}12}\PY{p}{)}
\PY{n}{solver}\PY{o}{.}\PY{n}{setRelativeTolerance}\PY{p}{(}\PY{l+m+mf}{1e\PYZhy{}12}\PY{p}{)}
\PY{n}{solver}\PY{o}{.}\PY{n}{setMaxSteps}\PY{p}{(}\PY{n+nb}{int}\PY{p}{(}\PY{l+m+mf}{1e5}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    pyPESTO also supports extrapolation methods that iteratively update
initial guesses for steady states by linearly extrapolating previously
found steady states based on steady state sensitivities. As this may
lead to issues when combined with forward, simulation based sensitivity
analysis, we deactivate this option here. To set the option, we create a
new
\href{https://pypesto.readthedocs.io/en/latest/api_objective.html\#pypesto.objective.AmiciObjective}{\texttt{AmiciObjective}}
instance and pass the model solver and model instance we previously
created to ensure that all options that we previously set are applied
during evaluation of the objective.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{25}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{obj} \PY{o}{=} \PY{n}{importer}\PY{o}{.}\PY{n}{create\PYZus{}objective}\PY{p}{(}\PY{n}{model}\PY{o}{=}\PY{n}{model}\PY{p}{,} \PY{n}{solver}\PY{o}{=}\PY{n}{solver}\PY{p}{)}
\PY{n}{obj}\PY{o}{.}\PY{n}{guess\PYZus{}steadystate} \PY{o}{=} \PY{k+kc}{False}
\end{Verbatim}
\end{tcolorbox}

    Lastly, we instantiate a pyPESTO
\href{https://pypesto.readthedocs.io/en/latest/api_problem.html\#pypesto.problem.Problem}{\texttt{Problem}}
and attach the
\href{https://pypesto.readthedocs.io/en/latest/api_objective.html\#pypesto.objective.AmiciObjective}{\texttt{AmiciObjective}}
we created.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{26}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{pypesto\PYZus{}problem} \PY{o}{=} \PY{n}{importer}\PY{o}{.}\PY{n}{create\PYZus{}problem}\PY{p}{(}\PY{n}{objective}\PY{o}{=}\PY{n}{obj}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    As gradient based methods are local methods, they have guaranteed
convergence to local minima (at least theoretically) and multiple
repeated optimization runs initialized at different points in \(\Theta\)
have to be started to explore the objective function landscape
~\cite{2754712/NDTJEJ2U}. Selecting an appropriate number of optimization
runs can be challenging, but should generally be adapted to the
downstream analysis. For example, when model selection or uncertainty
analysis using profile likelihoods will be performed, it is crucial to
ensure that optimization reaches a local optimum and that the local
optimum is, or at least yields a fit equivalent to, the global optimum.
This can be achieved by running many optimization runs and allocating
large computational budgets for each run. For large models, the total
computational budget usually is insufficient to achieve these goals and
the number of runs and the computational budget has to be limited, with
an unknown tradeoff between the two. To deal with this tradeoff, we will
here use a two-staged approach where we first run many starts with a low
computational budget of 10 minutes. This will just be enough for a
handful of iterations and we will then select the most promising runs
and continue optimization with a larger computational budget. As
optimizer, we employ fides~\cite{2754712/RUR9I9SQ}, a high performance trust-region optimizer
permitting the direct specification of the computational budgets, which
can be interfaced in pyPESTO using the
\href{https://pypesto.readthedocs.io/en/latest/api_optimize.html\#pypesto.optimize.FidesOptimizer}{\texttt{FidesOptimizer}}
class.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{27}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pypesto}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{FidesOptimizer}
\PY{k+kn}{import} \PY{n+nn}{fides}
\PY{k+kn}{import} \PY{n+nn}{logging}

\PY{n}{optimizer} \PY{o}{=} \PY{n}{FidesOptimizer}\PY{p}{(}\PY{n}{options}\PY{o}{=}\PY{p}{\PYZob{}}\PY{n}{fides}\PY{o}{.}\PY{n}{Options}\PY{o}{.}\PY{n}{MAXTIME}\PY{p}{:} \PY{l+m+mi}{600}\PY{p}{\PYZcb{}}\PY{p}{,}
                           \PY{n}{verbose}\PY{o}{=}\PY{n}{logging}\PY{o}{.}\PY{n}{ERROR}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Now we have everything at hand to run the first calibration stage. Here,
we run 100 optimization runs with random starting points (uniformly
sampled by default) using the pyPESTO
\href{https://pypesto.readthedocs.io/en/latest/api_optimize.html\#pypesto.optimize.minimize}{\texttt{minimize}}
function. The calibration is parallelized using pyPESTOs
\href{https://pypesto.readthedocs.io/en/latest/api_engine.html\#pypesto.engine.MultiThreadEngine}{\texttt{MultiThreadEngine}}
with 4 threads.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{28}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pypesto}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{minimize}
\PY{n}{result} \PY{o}{=} \PY{n}{minimize}\PY{p}{(}
    \PY{n}{pypesto\PYZus{}problem}\PY{p}{,} \PY{n}{optimizer}\PY{p}{,} \PY{n}{n\PYZus{}starts}\PY{o}{=}\PY{l+m+mi}{100}\PY{p}{,}
    \PY{n}{engine}\PY{o}{=}\PY{n}{pypesto}\PY{o}{.}\PY{n}{engine}\PY{o}{.}\PY{n}{MultiThreadEngine}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{,}
    \PY{n}{progress\PYZus{}bar}\PY{o}{=}\PY{k+kc}{False}\PY{p}{,}
\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    To assess whether the quality of the calibration, we will now use the
PEtab visualization feature. The visualization instructions are
specified in a
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#visualization-table}{\texttt{visualization\ table}},
where, in the case of line plots, every row corresponds to a single pair
of connected lines for data and simulation. Here we make use of the of
the \texttt{petab.DATASET\_ID} values that we specified in the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#measurement-table}{\texttt{measurement\ table}}.
In the following we will generate seperate plots for each observable and
each inhibitor, where every plot shows the dose response in the EGF
stimulated and unstimulated condition. The visualization table is then
attached to the previously created \texttt{petab\_problem}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{29}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{visualization\PYZus{}table} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{[}
    \PY{p}{\PYZob{}}
        \PY{n}{petab}\PY{o}{.}\PY{n}{PLOT\PYZus{}ID}\PY{p}{:} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{rafi}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{obs}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{PLOT\PYZus{}TYPE\PYZus{}SIMULATION}\PY{p}{:} \PY{n}{petab}\PY{o}{.}\PY{n}{LINE\PYZus{}PLOT}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{PLOT\PYZus{}TYPE\PYZus{}DATA}\PY{p}{:} \PY{n}{petab}\PY{o}{.}\PY{n}{MEAN\PYZus{}AND\PYZus{}SD}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{DATASET\PYZus{}ID}\PY{p}{:} \PY{n}{condition}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{X\PYZus{}VALUES}\PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RAFi\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{Y\PYZus{}VALUES}\PY{p}{:} \PY{n}{obs}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{X\PYZus{}SCALE}\PY{p}{:} \PY{n}{petab}\PY{o}{.}\PY{n}{LOG10}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{X\PYZus{}LABEL}\PY{p}{:} \PY{n}{rafi}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{Y\PYZus{}LABEL}\PY{p}{:} \PY{n}{obs}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{LEGEND\PYZus{}ENTRY}\PY{p}{:} \PY{n}{condition}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
    \PY{p}{\PYZcb{}}
    \PY{k}{for} \PY{n}{rafi} \PY{o+ow}{in} \PY{n}{RAFis}
    \PY{k}{for} \PY{n}{obs} \PY{o+ow}{in} \PY{n}{observables\PYZus{}table}\PY{o}{.}\PY{n}{index}
    \PY{k}{for} \PY{n}{condition} \PY{o+ow}{in} \PY{n}{measurement\PYZus{}table}\PY{p}{[}\PY{n}{petab}\PY{o}{.}\PY{n}{DATASET\PYZus{}ID}\PY{p}{]}\PY{o}{.}\PY{n}{unique}\PY{p}{(}\PY{p}{)}
    \PY{k}{if} \PY{n}{condition}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{==} \PY{n}{rafi}
\PY{p}{]}\PY{p}{)}
\PY{n}{petab\PYZus{}problem}\PY{o}{.}\PY{n}{visualization\PYZus{}df} \PY{o}{=} \PY{n}{visualization\PYZus{}table}
\end{Verbatim}
\end{tcolorbox}
        
    While experimental data for visualization is already available in the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#measurement-table}{\texttt{measurement\ table}},
simulations of the calibrated model still have to be computed. To
generate model simulations, we extract the parameter values of the best
pre-calibration. As optimization results are sorted in increasing order
of objective function values, this can be achieved by taking the result
at the first index. PEtab compatible simulation results can be extracted
using the pyPESTO objective and the AMICI function
\href{https://amici.readthedocs.io/en/latest/generated/amici.petab_objective.html\#amici.petab_objective.rdatas_to_measurement_df}{\texttt{amici.petab\_objective.rdatas\_to\_simulation\_df}}.
As the results contains the full parameter vector, including parameter
values that were not estimated, but the objective only expects estimated
parameters, the parameters need to be subsetted according to the free
indices.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{30}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{x} \PY{o}{=} \PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{get\PYZus{}reduced\PYZus{}vector}\PY{p}{(}\PY{n}{result}\PY{o}{.}\PY{n}{optimize\PYZus{}result}\PY{o}{.}\PY{n}{list}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                                       \PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{x\PYZus{}free\PYZus{}indices}\PY{p}{)}
\PY{n}{simulation} \PY{o}{=} \PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{objective}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{return\PYZus{}dict}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
\PY{n}{simulation\PYZus{}df} \PY{o}{=} \PY{n}{amici}\PY{o}{.}\PY{n}{petab\PYZus{}objective}\PY{o}{.}\PY{n}{rdatas\PYZus{}to\PYZus{}simulation\PYZus{}df}\PY{p}{(}
    \PY{n}{simulation}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{rdatas}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
    \PY{n}{model}\PY{o}{=}\PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{objective}\PY{o}{.}\PY{n}{amici\PYZus{}model}\PY{p}{,}
    \PY{n}{measurement\PYZus{}df}\PY{o}{=}\PY{n}{measurement\PYZus{}table}\PY{p}{,}
\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    We can now visualize both data and simulation using
\href{https://petab.readthedocs.io/projects/libpetab-python/en/latest/build/_autosummary/petab.visualize.html\#petab.visualize.plot_problem}{\texttt{petab.visualize.plot\_problem}}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{31}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{petab}\PY{n+nn}{.}\PY{n+nn}{visualize}
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}

\PY{n}{plt}\PY{o}{.}\PY{n}{rc}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{font}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{size}\PY{o}{=}\PY{l+m+mi}{25}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{rc}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{lines}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{linewidth}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}

\PY{n}{petab}\PY{o}{.}\PY{n}{visualize}\PY{o}{.}\PY{n}{plot\PYZus{}problem}\PY{p}{(}
    \PY{n}{petab\PYZus{}problem}\PY{o}{=}\PY{n}{petab\PYZus{}problem}\PY{p}{,}
    \PY{n}{simulations\PYZus{}df}\PY{o}{=}\PY{n}{simulation\PYZus{}df}\PY{p}{,}
\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

\begin{figure}[!h]
\centering
\adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{chapter_files/chapter_75_0.png}

\caption{Pre-calibration fit. Different rows correspond to different RAF inhibitors (vemurafenib and dabrafenib). Different columns correspond to different observables (pMEK and pERK). Colors indicate different experimental conditions (with and without EGF stimulation). Data is shown as dashed lines, simulations as solid lines.}
\label{fig:fit_precal}
\end{figure}
    
    The generated figure (Fig.~\ref{fig:fit_precal}) suggests that model simulations are qualitatively
similar to training data, but there are still large quantitative
differences. This suggests that the pre-calibrated parameter values are
an adequate first guess, but require further refinement.

Before we proceed with the second calibration round, we can check the
accuracy of the objective function gradient at the pre-calibrated
parameter values. For this purpose, we use the
\href{https://pypesto.readthedocs.io/en/latest/api_objective.html\#pypesto.objective.ObjectiveBase.check_grad_multi_eps}{\texttt{check\_grad\_multi\_eps}}
method, which approximates the objective function gradient using finite
differences with different step sizes.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{32}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{pd}\PY{o}{.}\PY{n}{set\PYZus{}option}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{display.max\PYZus{}rows}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}
\PY{n}{pd}\PY{o}{.}\PY{n}{set\PYZus{}option}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{display.max\PYZus{}columns}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{)}
\PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{objective}\PY{o}{.}\PY{n}{check\PYZus{}grad\PYZus{}multi\PYZus{}eps}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{multi\PYZus{}eps}\PY{o}{=}\PY{p}{[}\PY{l+m+mf}{1e\PYZhy{}1}\PY{p}{,} \PY{l+m+mf}{1e\PYZhy{}3}\PY{p}{,} \PY{l+m+mf}{1e\PYZhy{}5}\PY{p}{]}\PY{p}{,} \PY{n}{verbosity}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{33}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
                        grad         fd\_f         fd\_b         fd\_c  \textbackslash{}
bind\_RAF\_RAF\_Ea    -0.000676     0.066034    -0.082687    -0.008326
bind\_RAF\_RAF\_dG   151.299971   161.357110   141.392663   151.374887
{\ldots}                      {\ldots}          {\ldots}          {\ldots}          {\ldots}
pERK\_offset       -14.721473    -7.347211   -22.133442   -14.740327
pERK\_scale      -1593.045905 -1569.867010 -1616.507993 -1593.187501

                    fd\_err   abs\_err   rel\_err    eps
bind\_RAF\_RAF\_Ea   0.148720  0.007650  0.083453  0.100
bind\_RAF\_RAF\_dG  19.964446  0.074916  0.000495  0.100
{\ldots}                    {\ldots}       {\ldots}       {\ldots}    {\ldots}
pERK\_offset      14.786231  0.018853  0.001279  0.001
pERK\_scale       46.640983  0.141596  0.000089  0.001

[28 rows x 8 columns]
\end{Verbatim}
\end{tcolorbox}
        
    The method computes forward (\texttt{fd\_c}), backward (\texttt{fd\_b})
and central (\texttt{fd\_c}) finite differences and compares them to the
sensitivity based gradient (\texttt{grad}), using the step size
\texttt{eps} that yields the lowest finite difference approximation
error among the provided step sizes. The results show a low error in the
finite difference approximation (\texttt{fd\_err}), indicating accurate
evaluation of the objective function. Moreover, the small absolute
(\texttt{abs\_err}) and relative difference (\texttt{rel\_err}) between
sensitivity based gradient and finite difference approximation indicates
accurate evaluation of the gradient. The large magnitude of the gradient
suggest that we did not yet reach a local optimum and that further
optimization will likely improve agreement between data and simulation.
In cases where either \texttt{fd\_err}, \texttt{abs\_err} or
\texttt{rel\_err} take large values, it is recommended to decrease
integration tolerances until adequate numbers are achieved, where
entries in \texttt{grad} can serve as reference.

We will now perform this refinement by instantiating a new optimizer with
a larger computational budget of two hours.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{33}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{optimizer\PYZus{}fine} \PY{o}{=} \PY{n}{FidesOptimizer}\PY{p}{(}\PY{n}{options}\PY{o}{=}\PY{p}{\PYZob{}}\PY{n}{fides}\PY{o}{.}\PY{n}{Options}\PY{o}{.}\PY{n}{MAXTIME}\PY{p}{:} \PY{l+m+mi}{7200}\PY{p}{\PYZcb{}}\PY{p}{,}
                                \PY{n}{verbose}\PY{o}{=}\PY{n}{logging}\PY{o}{.}\PY{n}{ERROR}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    To initialize the second calibration round at the pre-calibrated
parameter values, we extract the respective values from the results
object and set them as guesses in the pyPESTO problem.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{34}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{n\PYZus{}refine} \PY{o}{=} \PY{l+m+mi}{10}
\PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{x\PYZus{}guesses\PYZus{}full} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{vstack}\PY{p}{(}\PY{n}{result}\PY{o}{.}\PY{n}{optimize\PYZus{}result}\PY{o}{.}\PY{n}{x}\PY{p}{[}\PY{p}{:}\PY{n}{n\PYZus{}refine}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    For startpoint generation, pyPESTO will first start optimization runs at
the provided parameter guesses and only sample new startpoint if more
optimization runs than guesses are requested. As for the first
calibration run, we run the calibration, using the pyPESTO
\href{https://pypesto.readthedocs.io/en/latest/api_optimize.html\#pypesto.optimize.minimize}{\texttt{minimize}}
function.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{35}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{result\PYZus{}refined} \PY{o}{=} \PY{n}{minimize}\PY{p}{(}
    \PY{n}{pypesto\PYZus{}problem}\PY{p}{,} \PY{n}{optimizer\PYZus{}fine}\PY{p}{,} \PY{n}{n\PYZus{}starts}\PY{o}{=}\PY{n}{n\PYZus{}refine}\PY{p}{,}
    \PY{n}{engine}\PY{o}{=}\PY{n}{pypesto}\PY{o}{.}\PY{n}{engine}\PY{o}{.}\PY{n}{MultiThreadEngine}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{,}
    \PY{n}{progress\PYZus{}bar}\PY{o}{=}\PY{k+kc}{False}\PY{p}{,}
\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    As for the pre-calibration, we now visualize the results using PEtab and
the previously constructed visualization table.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{36}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{x} \PY{o}{=} \PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{get\PYZus{}reduced\PYZus{}vector}\PY{p}{(}
    \PY{n}{result\PYZus{}refined}\PY{o}{.}\PY{n}{optimize\PYZus{}result}\PY{o}{.}\PY{n}{list}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
    \PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{x\PYZus{}free\PYZus{}indices}
\PY{p}{)}
\PY{n}{simulation} \PY{o}{=} \PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{objective}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{return\PYZus{}dict}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
\PY{n}{simulation\PYZus{}df} \PY{o}{=} \PY{n}{amici}\PY{o}{.}\PY{n}{petab\PYZus{}objective}\PY{o}{.}\PY{n}{rdatas\PYZus{}to\PYZus{}simulation\PYZus{}df}\PY{p}{(}
    \PY{n}{simulation}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{rdatas}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
    \PY{n}{model}\PY{o}{=}\PY{n}{importer}\PY{o}{.}\PY{n}{create\PYZus{}model}\PY{p}{(}\PY{p}{)}\PY{p}{,}
    \PY{n}{measurement\PYZus{}df}\PY{o}{=}\PY{n}{measurement\PYZus{}table}\PY{p}{,}
\PY{p}{)}

\PY{n}{plt}\PY{o}{.}\PY{n}{rc}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{font}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{size}\PY{o}{=}\PY{l+m+mi}{20}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{rc}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{lines}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{linewidth}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}

\PY{n}{petab}\PY{o}{.}\PY{n}{visualize}\PY{o}{.}\PY{n}{plot\PYZus{}problem}\PY{p}{(}
    \PY{n}{petab\PYZus{}problem}\PY{o}{=}\PY{n}{petab\PYZus{}problem}\PY{p}{,}
    \PY{n}{simulations\PYZus{}df}\PY{o}{=}\PY{n}{simulation\PYZus{}df}\PY{p}{,}
\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

\begin{figure}[!h]
\centering
\adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{chapter_files/chapter_85_1.png}

\caption{Calibration fit. Different rows correspond to different RAF inhibitors (vemurafenib and dabrafenib). Different columns correspond to different observables (pMEK and pERK). Colors indicate different experimental conditions (with and without EGF stimulation). Data is shown as dashed lines, simulations as solid lines.}
\label{fig:fit_cal}
\end{figure}
    
    These generated figure (Fig.~\ref{fig:fit_cal}) now indicate adequate agreement between
experimental data and model simulations. As a last step of the analysis,
we now compare the objective function values across both calibration
rounds using a waterfall plot.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{37}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pypesto}\PY{n+nn}{.}\PY{n+nn}{visualize} \PY{k+kn}{import} \PY{n}{waterfall}
\PY{n}{waterfall}\PY{p}{(}\PY{n}{results}\PY{o}{=}\PY{p}{[}\PY{n}{result}\PY{p}{,}\PY{n}{result\PYZus{}refined}\PY{p}{]}\PY{p}{,}
          \PY{n}{legends}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pre\PYZhy{}calibration}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{calibration}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

\begin{figure}[!h]
\centering
\adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{chapter_files/chapter_87_1.png}

\caption{Waterfall plot. Objective function values from (pre-) calibration runs are sorted according to their sorted numerical value. Y-axis is offsetted such that lowest objective function value is shown at 1.}
\label{fig:waterfall}
\end{figure}
    
    The generated waterfall plot (Fig.~\ref{fig:waterfall}) shows sorted objective function values of
different optimizer runs for pre-calibration (blue) and calibration (yellow). The
objective function values are normalized to the best objective function
value achieved across both runs. We observe that for the majority of
fully calibrated runs, we achieve much lower objective function values
compared to the pre-calibrated runs, indicating that the higher
computational budget facilitated better fits. For a small subset of
starts, we observe repeated convergence to similar objective function
values that form a plateau in the waterfall plot, suggesting that the
respective runs may have converged to the same local minimum. Ideally,
the majority of objective function values would lie in a plateau, but
this would likely require many more optimizer runs with larger
computational budgets and would thus have to be performed on a computer
cluster.

    \hypertarget{discussion}{%
\section{Discussion}\label{discussion}}

Even with state-of-the-art methods the process of model formulation,
problem specification and calibration we described in this protocol
remains a labour intensive process, where good understanding of the
underlying mathematical concepts is necessary to achieve optimal, or even
adequate performance for large kinetic models. We anticipate that the
extensive description and code we provide in this protocol will serve as
an introduction to model calibration and may be used as template for
future research projects.

In terms of future developments, more automation in terms of tolerance
selection, sensitivity methods and computational budget allocation will
be necessary to improve accessibility of methods and reduce the amount
of required user interaction. Some frameworks such as data2dynamics
~\cite{2754712/RYRYBYZA} already provide adaptive tolerance updating
schemes in cases of numerical integration failure. This could still be
complemented by adaptive updating of tolerances based on objective
function evaluation accuracy, but underlying mathematical theory and
good benchmark problems are missing. We are convinced that the
introduction of large benchmarks in~\cite{2754712/FMD3RVCR,2754712/INKV577L}, guidelines for their evaluation
~\cite{2754712/NYMSV8TA} as well as the standardization of their
formulation~\cite{2754712/86CV69R2} will prove to be crucial to improve
automation of model calibration in the future.

\bibliographystyle{unsrt}
\bibliography{chapter_files/chapter.bib}

\end{document}