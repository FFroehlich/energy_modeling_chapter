\documentclass[11pt]{article}

    \usepackage[breakable]{tcolorbox}
    \usepackage{parskip} % Stop auto-indenting (to mimic markdown behaviour)
    
    \usepackage{iftex}
    \ifPDFTeX
    	\usepackage[T1]{fontenc}
    	\usepackage{mathpazo}
    \else
    	\usepackage{fontspec}
    \fi

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range
    \makeatletter % fix for old versions of grffile with XeLaTeX
    \@ifpackagelater{grffile}{2019/11/01}
    {
      % Do nothing on new versions
    }
    {
      \def\Gread@@xetex#1{%
        \IfFileExists{"\Gin@base".bb}%
        {\Gread@eps{\Gin@base.bb}}%
        {\Gread@@xetex@aux#1}%
      }
    }
    \makeatother
    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{titling}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}
    

    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % common color for the border for error outputs.
    \definecolor{outerrorbackground}{HTML}{FFDFDF}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    \newcommand{\dims}[1]{{n_{#1}}}
    % Document parameters
    % Document title
    \title{A Practical Guide for the Efficient Formulation and Calibration
of Large, Energy Rule-Based Models of Cellular Signal
Transduction}

\author{
Fabian Fröhlich\,$^{\text{1}}$
}
\date{%
$^{\text{\sf 1}}$Department of Systems Biology, Harvard Medical School, Boston, MA 02115, USA,\\
}
    
% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb. 
    \makeatletter
        \newbox\Wrappedcontinuationbox 
        \newbox\Wrappedvisiblespacebox 
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}} 
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}} 
        \newcommand*\Wrappedcontinuationindent {3ex } 
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox} 
        % Take advantage of the already applied Pygments mark-up to insert 
        % potential linebreaks for TeX processing. 
        %        {, <, #, %, $, ' and ": go to next line. 
        %        _, }, ^, &, >, - and ~: stay at end of broken line. 
        % Use of \textquotesingle for straight quote. 
        \newcommand*\Wrappedbreaksatspecials {% 
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}% 
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}% 
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}% 
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}% 
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}% 
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}% 
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}% 
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}% 
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}% 
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}% 
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}% 
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}% 
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}% 
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}% 
        } 
        % Some characters . , ; ? ! / are not pygmentized. 
        % This macro makes them "active" and they will insert potential linebreaks 
        \newcommand*\Wrappedbreaksatpunct {% 
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}% 
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}% 
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}% 
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}% 
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}% 
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}% 
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}% 
            \catcode`\.\active
            \catcode`\,\active 
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active 
            \lccode`\~`\~ 	
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%
        
        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active 	
        \OriginalVerbatim[#1,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{F7F7F7}
    
    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        {\ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}}
    }
    

    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

\begin{document}
    
    \maketitle
    
    

    \hypertarget{abstract}{%
\section*{Abstract}\label{abstract}}

    Aberrant signal transduction leads to complex diseases such as cancer.
To rationally design treatment strategies with small molecule
inhibitors, computational models have to be employed. Energy- and rule-based
models allow the construction of mechanistic ordinary differential
equation models based on structural insights. The detailed, energy-based
decription often generates large models, which are difficult to
calibrate on experimental data. In this chapter, we provide a detailed,
interactive protocol for the programmatic formulation and calibration of
such large, energy- and rule-based models of cellular signal transduction based on an example model describing the action of RAF inhibitors on MAPK signaling.

    \hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

    Cells use signal transduction to respond to extracellular cues,
controlling a variety of different cellular processes such as
proliferation, development and environmental adaption
\cite{2754712/YK9CS8BY}. Signal transduction is initiated by the binding
of extracellular ligands to transmembrane receptors
\cite{2754712/QR4JIKLV} and then propagated through phosphorylation
cascades \cite{2754712/B6ZP8LH6,2754712/NPR437GQ}, ultimately
controlling gene expression through modulation of transcription factor
activity. Mutations and changes in protein expression levels can
dysregulate signal transduction leading to a variety of different
diseases such as cancer \cite{2754712/L8NRTXRQ}. Small molecule
inhibitors can be used to target specific proteins that participate in
aberrant signal transduction \cite{2754712/7ZXBI6XG}. However, feedback
mechanisms and cross-talk between signaling cascades, which are
ubiquitous to cellular signal transduction, lead to complex, non-linear
responses to drug inhibition \cite{2754712/URVR5RD5}, making it
difficult to anticipate the phenotypic responses or resistances to these
inhibitors. Accordingly, computational models that describe signal
transduction, and the effect of drug perturbations on it, are required for
the rational selection and dosage of targeted inhibitors
\cite{2754712/DUK5BLQ4}. Mechanistic computational models of cellular
signal transduction translate biological knowledge into executable
mathematical formulations \cite{2754712/6JVZVNVK}. To this end, ordinary
differential equations (ODE) models are a popular modeling approach, as they
can describe temporal dynamics and feedback mechanisms
\cite{2754712/X784IDZJ}. Moreover, state variables and parameters
correspond to biophysical entities, facilitating a direct interpretation
of model simulations and predictions.

    Formulation of such models is often a long labour intensive process,
especially for large models. Instead of directly writing model
equations, which can be tedious and error-prone, it is advisable
to use some kind of abstraction when writing models. For example, the
Systems Biology Markup Language (SBML) \cite{2754712/NF7FZULE} encodes
models using concepts such as reactions and events, which can then be
translated in to differential equation models. Rule-based formats such
as Kappa \cite{2754712/NAKF6985} or BioNetGen \cite{2754712/M82A4YPP}
employ even higher levels of abstractions and describe model equations in terms of rules, which are
generalizations of reactions \cite{2754712/MIF24GAE}. While such
abstractions can limit what kind of models can be expressed, they also permit a more
compact model description. A recent extension to rule based models are
energy rule-based models \cite{2754712/6CAKFQQP}
\cite{2754712/QTNJGKHE}, which provide an additional layer of
abstraction, by specifying rules rates in terms of energies.
Conceptually, energies permit the theoretically sound formulation of
reaction rates based on transition state theory and provide a rigorous
way of specifying context dependent reaction rates based on structural
insights \cite{2754712/7TJH2IAK,2754712/DI7IDWLV}. Practically,
energy based models enforce thermodynamic constraints such as the
Wegscheider-Lewis cycle conditions \cite{2754712/VAJ8A9TA}, which ensure
the conservation of energy in oligomerization process. This is
particularly relevant for the specification of context dependent
inhibitor affinities. For example, many RAF inhibitors have different
affinities for RAF monomers and dimers, which is responsible for the
clinically observed phenomenon of ``paradoxical activation''
\cite{2754712/68C3KR4X,2754712/GPZDY42G,2754712/46UNKAAD}.

    Calibration large models can also be challenging. During
model calibration, parameter values are tuned such that model
simulations agree with experimental data, which improves the predictive
performance of models. Agreement between model simulations and
experiments can be quantified using likelihood-based objective
functions, in which case model calibration can be implemented through
minimization of the respective objective function. For larger models,
gradient-based optimization methods perform well
\cite{2754712/INKV577L}. However, for non-linear models, analytical
solutions to model equations are rarely available, which means that
numerical integration is necessary for evaluation of the objective
function and its derivatives. Accordingly, gradient-based methods not only require
integration of model equations, but also sensitivity equations, which
quantify the dependence of simulations on model parameters. For large
models, adjoint sensitivity analysis is an effective way of computing
these sensitivities, but also comes with it's drawbacks such as not
permitting the computation of cheap approximations to the second order
derivative, which could boost optimizer efficiency
\cite{2754712/MKPQ9727}.

    Model formulation and calibration for large models can be a daunting
task \cite{2754712/C7C8DJNE}, even when using specialized software
tools. Input formats such as SBML or PEtab \cite{2754712/86CV69R2}
permit the standardized problem formulation, which allows the automation
of the majority of steps. However, manual interventions are still
occasionally necessary to achieve optimal performance. These manual interventions often require substantial practical experience as well as
theoretical background knowledge, which creates a high entry barrier and means that successful
development and application of large models is often not possible
without guidance from experts. To rectify this situation, we here provide
a detailed, step-by-step protocol for the formulation and calibration of a simplified version of a large scale
model introduced in \cite{2754712/I4JQ4DMV}. In contrast to previous
protocols for ODE model calibration~\cite{2754712/3DK88XY2,2754712/WCVMC7CZ,2754712/D7NTVFNN,2754712/RFM5WDSL,2754712/S5LTETKT,2754712/HWVK2XI8,2754712/5ZMDTVIQ,2754712/Y2DU9IB4,2754712/5SLVJFMG}, this
protocol includes a description of energy-based model formulation, focuses on large-scale models of intracellular signaling and includes an interactive jupyter notebook which allows reproduction of all results. As
in other protocols, theoretical background is provided when appropriate.
The protocol does not provide details about additional
analysis steps such as identifiability or uncertainty analysis and model
selection, for which specialized reviews and protocols have to be consulted~\cite{2754712/SP36R7LH,2754712/HHEWVKQL,2754712/NDTJEJ2U}. The protocol uses the python
toolboxes PySB~\cite{2754712/7D6BBY4A}, PEtab~\cite{2754712/86CV69R2}, AMICI~\cite{2754712/HBAI2XHJ}, pyPESTO and fides~\cite{2754712/RUR9I9SQ} and is accompanied by
a jupyter notebook that permits the interactive reproduction of results.

    \hypertarget{mathematical-problem-formulation}{%
\section{Mathematical Problem
Formulation}\label{mathematical-problem-formulation}}

For ODE models, the temporal
evolution of abundances of \(\dims{x}\) different molecular species
\(x_i\) is determined by the
vector field $\textbf{f}$ and the initial conditions \(\textbf{x}_0\):

\begin{equation}
\dot{\textbf{x}}=\textbf{f}(t,\textbf{x},\boldsymbol{\gamma}),\quad \textbf{x}(t_0) = \textbf{x}_0(\boldsymbol{\gamma}).
\label{eq:ode}
\end{equation}

Both \(\textbf{f}\) and \(\textbf{x}_0\) may depend on dynamic
parameters \(\boldsymbol{\gamma}\), which may include kinetic parameters
such as catalytic or binding rates or condition parameters such as
ligand or drug concentrations.

Calibration is performed by comparing model simulations, i.e., solutions
\(\textbf{x}\) that satisfy \(\eqref{eq:ode}\), to experimental data
\(\bar{\textbf{y}}\). As direct measurement of \(\textbf{x}\) is usually
experimentally not possible, observables

\begin{equation}
\textbf{y}(t,\boldsymbol{\gamma},\boldsymbol{\xi}) = \textbf{g}(\textbf{x}(t,\boldsymbol{\gamma}),\boldsymbol{\xi})
\label{eq:observable}
\end{equation}

are introduced, which may depend on abundances \(\textbf{x}\) as well as
observable parameters \(\boldsymbol{\xi}\) such as scaling parameters or
offsets. The agreement between model observables \(\textbf{y}\) and
experimental measurements \(\bar{\textbf{y}}\) can be quantified
according to the assumed noise model. A common assumption is that the
measurement noise for \(\dims{y}\) observables \(y_i\) is additive and
independently, normally distributed:

\begin{equation}
\bar{y}_{i} = y_i(t,\boldsymbol{\gamma},\boldsymbol{\xi}) + \epsilon_{i}, \quad \epsilon_{i} \overset{id}{\sim} \mathcal{N}(0,\sigma_{i}^2(\boldsymbol{\psi}))
\label{eq:noise}
\end{equation}

where \(\boldsymbol{\psi}\) are noise parameters that encode the
standard deviations \(\boldsymbol{\sigma}\). Using this noise model, the
negative log-likelihood

\begin{equation}
\begin{aligned}
J(\boldsymbol{\theta}) =&  \frac{1}{2} \sum_{i=k}^\dims{k} \sum_{(i,j) \in T_k} \log\left(2\pi\sigma_{i}^2(\boldsymbol{\Psi}_{ijk}(\boldsymbol{\theta}))\right) + \left(\frac{\bar{y}_{ijk} - y_{i}(t_j,\boldsymbol{\Gamma}_k(\boldsymbol{\theta}),\boldsymbol{\Xi}_{ijk}(\boldsymbol{\theta}))}{\sigma_{i}(\boldsymbol{\Psi}_{ijk}(\boldsymbol{\theta}))}\right)^2
\label{eq:objective}
\end{aligned}
\end{equation}

statistically rigorously quantifies the agreement between experimental
data and model simulations, where \(\boldsymbol{\theta}\) are the free,
unknown parameters, \(T_k\) is the set of timepoints \(t_j\) and observable
\(y_i\) index combinations that were measured in the \(k\)-th out of
\(\dims{k}\) experimental conditions, \(\boldsymbol{\Psi}_{ijk}\) is a
function that maps free parameters \(\boldsymbol{\theta}\) to
observable, timepoint and condition specific noise parameters
\(\boldsymbol{\psi}\), \(\boldsymbol{\Xi}_{ijk}\) is a function that
maps free parameters \(\boldsymbol{\theta}\) to observable, timepoint
and condition specific observable parameters \(\boldsymbol{\xi}\) and
\(\boldsymbol{\Gamma_{k}}\) is a function that maps free parameters
\(\boldsymbol{\theta}\) to condition specific dynamic parameters
\(\boldsymbol{\gamma}\) . As the logarithm is a strictly monotonously
increasing function, the minimization of $ J(\boldsymbol{\theta})$ is
equivalent to the maximization of the likelihood. Therefore, the
corresponding minimization problem

\begin{equation}
\boldsymbol{\theta}^* = \arg \min_{\boldsymbol{\theta} \in \Theta} J(\boldsymbol{\theta}),
\label{eq:mle}
\end{equation}

will infer the Maximum Likelihood Estimate \(\boldsymbol{\theta}^*\) for
free parameters \(\boldsymbol{\theta}\), where the search domain
\(\Theta\subset{\mathbb{R}}^{\dims{\theta}}\) restricts  \(\boldsymbol{\theta}\) to values that are biologically
reasonable and prevents numerical integration failures. For most
problems, \(\Theta\) is chosen as tensor product of scalar search
domains \((\mathcal{L}_l,\mathcal{U}_l)\) with lower and upper boundaries
\(\mathcal{L}_l, \mathcal{U}_l \in \mathbb{R}\cup\{-\infty,\infty\}\)
for every parameter \(\theta_l\).

    \hypertarget{formulating-a-thermodynamic-model-of-raf-inhibition-in-pysb}{%
\section{Formulating a Thermodynamic Model of RAF inhibition in
PySB}\label{formulating-a-thermodynamic-model-of-raf-inhibition-in-pysb}}

    In the following, we will specify the model, which in turn defines the
right hand side \(\textbf{f}\) and the initial conditions
\(\textbf{x}_0\) of the model equations. We will specify the model using
the rule-based modeling framework PySB, which instead of direct
specification of \(\textbf{f}\), programmatically encodes model
structure in a modular, object oriented way, ensuring reusability,
composability and extendability of models \cite{2754712/7D6BBY4A}. To
start model specification, we instantiate a PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Model}{\texttt{Model}}
with name \texttt{thermo\_raf}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{1}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pysb} \PY{k+kn}{import} \PY{n}{Model}
\PY{n}{model} \PY{o}{=} \PY{n}{Model}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{thermo\PYZus{}raf}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{protein-species}{%
\subsection{Protein Species}\label{protein-species}}

As first step of model construction, we have to define all molecules
that we want to account for. In PySB, this is done by instantiating the
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Monomer}{\texttt{Monomer}} class. Each monomer is initialized by a unique
identifier, a list of sites as well as, optionally, a list of possible states for
each site. Sites typically correspond to binding domains or residues
that can be mutated or modified post-translationally, where the site states encode the different all possible mutations or post-translational modifications for each site. All sites,
independent of whether possible states were specified or not, can form a
bond with other sites, permitting the description of macromolecular complexes.

Here, we will define monomers \texttt{BRAF} and \texttt{CRAF} which
both feature the interaction sites \texttt{RBD} (interaction domain with
RAS), \texttt{mek} (interaction domain with MEK), \texttt{raf}
(dimerization domain) and \texttt{rafi} (inhibitor binding site). For
BRAF we also add a mutation sites for the 600th amino acid, which can
take values \texttt{V} (valine, wildtype) or \texttt{E} (glutamic acid,
oncogenic mutation).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pysb} \PY{k+kn}{import} \PY{n}{Monomer}
\PY{n}{Monomer}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BRAF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{AA600}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RBD}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{mek}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{raf}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{rafi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{AA600}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{E}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{V}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
\PY{n}{Monomer}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{CRAF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RBD}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{mek}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{raf}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{rafi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    Next, we will specify initial concentrations. For this model, the
concentration of all molecular species will be in \(\mu\mathrm{M}\).
However, we will use protein counts per cell derived from absolute
proteomics to inform initial conditions. Accordingly, parameters that
define initial concentrations have to be transformed from molecule per
cell to \(\mu\mathrm{M}\), which is achieved by dividing them by cell
volume (here assumed to be \(1pL = 10^{-12} L\)) and the Avogadro
constant (\(6.022 10^{23}\) molecules) and multiplying with \(10^{6}\)
to account for the unit prefix \(\mu\).

In the following code, we first introduce two PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Expression}{\texttt{Expression}}s
that specify the Avogadro constant and cell volume. As with most model components, PySB automatically
creates workspace variables with the respective identifier as variable names, simplifying the programmatic reference to components. Next, we
introduce two dynamic parameters $\boldsymbol{\gamma}$ (see
\(\eqref{eq:ode}\)) as PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Parameter}{\texttt{Parameter}}s
\texttt{BRAF\_0} and \texttt{CRAF\_0} that define initial abundances as
molecules per cell and convert these abundances to concentrations in
\(\mu\mathrm{M}\) using the expressions \texttt{initBRAF} and
\texttt{initCRAF}. These expressions are then used to define the initial
abundances for the two monomer species \texttt{CRAF} and \texttt{BRAF}
using the PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Initial}{\texttt{Initial}}
class, which specifies \(\textbf{x}_0\) for the respective molecular
species \(x_i\). In PySB, a molecular species is defined by a pattern that is created by invoking the respective monomer with the state of
each site as keyword argument. For initial conditions, the respective
patterns have to be explicit, i.e., the states of all sites that can have one or more states have to
specified. For the initial conditions, we specify that all sites are unbound (denoted by
\texttt{None}), with the exception of the the \texttt{AA600} site. For
the \texttt{AA600} site we have to pick one of the previously specified
states, which we do by specifying an oncogenic variant denoted by \texttt{E}. For
all molecular species without an explicit instantiation of
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Initial}{\texttt{Initial}},
the respective entry in \(\textbf{x}_0\) is set to \(0\).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pysb} \PY{k+kn}{import} \PY{n}{Parameter}\PY{p}{,} \PY{n}{Expression}\PY{p}{,} \PY{n}{Initial}
\PY{k+kn}{import} \PY{n+nn}{sympy} \PY{k}{as} \PY{n+nn}{sp}

\PY{c+c1}{\PYZsh{} define Avogadro constant and volume as hardcoded expressions}
\PY{n}{Expression}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{N\PYZus{}Avogadro}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{sp}\PY{o}{.}\PY{n}{Float}\PY{p}{(}\PY{l+m+mf}{6.02214076e+23}\PY{p}{)}\PY{p}{)}
\PY{n}{Expression}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{volume}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{sp}\PY{o}{.}\PY{n}{Float}\PY{p}{(}\PY{l+m+mf}{1e\PYZhy{}12}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} define initial abundance parameters }
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BRAF\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{CRAF\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} convert initial abundances to concentrations}
\PY{n}{Expression}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{initBRAF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mf}{1000000.0}\PY{o}{*}\PY{n}{BRAF\PYZus{}0}\PY{o}{/}\PY{p}{(}\PY{n}{N\PYZus{}Avogadro}\PY{o}{*}\PY{n}{volume}\PY{p}{)}\PY{p}{)}
\PY{n}{Expression}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{initCRAF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mf}{1000000.0}\PY{o}{*}\PY{n}{CRAF\PYZus{}0}\PY{o}{/}\PY{p}{(}\PY{n}{N\PYZus{}Avogadro}\PY{o}{*}\PY{n}{volume}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} define initial molecular species}
\PY{n}{Initial}\PY{p}{(}\PY{n}{BRAF}\PY{p}{(}\PY{n}{AA600}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{E}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{RBD}\PY{o}{=}\PY{k+kc}{None}\PY{p}{,} \PY{n}{mek}\PY{o}{=}\PY{k+kc}{None}\PY{p}{,} \PY{n}{raf}\PY{o}{=}\PY{k+kc}{None}\PY{p}{,} \PY{n}{rafi}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)}\PY{p}{,} \PY{n}{initBRAF}\PY{p}{)}
\PY{n}{Initial}\PY{p}{(}\PY{n}{CRAF}\PY{p}{(}\PY{n}{RBD}\PY{o}{=}\PY{k+kc}{None}\PY{p}{,} \PY{n}{mek}\PY{o}{=}\PY{k+kc}{None}\PY{p}{,} \PY{n}{raf}\PY{o}{=}\PY{k+kc}{None}\PY{p}{,} \PY{n}{rafi}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)}\PY{p}{,} \PY{n}{initCRAF}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{protein-interactions}{%
\subsection{Protein Interactions}\label{protein-interactions}}

For rule-based models, all dynamic interactions are specified as rules.
PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Rule}{\texttt{Rule}}s
are generalizations of biochemical reactions and their action is defined
by a reactant pattern and a product pattern. When applied to a molecular
species, the action of the rule, i.e., the respective biochemical
reaction, is implemented by applying the difference between the reactant
 and the product pattern to a match of the reactant pattern in a molecular species. In contrast to initials, the reactant
pattern and product pattern do not have to be explicit and a single rule
can define multiple different biochemical reactions, depending in how
often and in how many molecular species the reactant pattern occurs.

Non-thermodynamic rules additionally require forward reaction rates \(k_f\) and, if
applicable, reverse reaction rates \(k_r\). In contrast, thermodynamic
rules are specified in terms of activation energy \(E_a\) and the
phenomenological constant \(\phi\), the convex combination parameter
which encodes how much changes in free energy affect forwards and
reverse rates. For thermodynamic rules, the reaction rate also depends
on the free energy difference between reactants and products of the
reaction. The forward \(k_f\) and reverse
\(k_r\) reaction rates are then computed using the Arrhenius theory of reaction rates

\[k_f=\exp( - (E_a + \phi \Delta G)), \quad k_r=\exp( - (E_a + (\phi - 1) \Delta G))\]

with

\[\Delta G = - \sum_{r \in R} \Delta \Delta G_r + \sum_{p \in P} \Delta \Delta G_p\]

where \(E_a\) is the activation energy of the reaction, i.e., the free
energy difference between the reactant state and the transition state,
\(\Delta G\) is the free energy difference between the reactant and the
product states and \(\Delta \Delta G_r\) and \(\Delta \Delta G_p\) are
the free energy modifiers that apply to the reactants \(r\) in \(R\) and the
products \(p\) in \(P\) respectively. All energies are assumed to be normalized by the inverse of the product between temperature and Boltzmann constant $\frac{1}{RT}$. The \(\Delta \Delta G_r\) and
\(\Delta \Delta G_p\) energies can be specified by using the PySB
\texttt{EnergyPattern} class. When calculating reaction rates, eBNG not
only accounts for EnergyPatterns that apply to the reactant and product
patterns specified in the rule, but also those EnergyPatterns that
specifally apply to reactant and product species. Thus, reactions generated by thermodynamic rules do not always have the same reaction rate, where differences are modularly specified through EnergyPatterns. In contrast, all reactions generated by a single non-thermodynamic rule will have the same reaction rate, unless a local function is used for rate specification.

In the following we will specify the dimerization of RAF molecules. For this purpose, we
introduce three parameters: the activation energy for the binding
reaction \(E_a\) (Ea suffix), the Gibb's free energy of the formed bond
\(\Delta G\) (dG suffix), and the thermodynamic balance parameter \(\phi\) (phi
suffix).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}Ea}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}dG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}phi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    To enforce that the actication energy \(E_a = - \log(k_f)\) encodes the
forward reaction rate and
\(\Delta G = - \log(K) = -\log \left(\frac{k_r}{k_f}\right)\) encodes
the affinity constant \(K\), we will pass a specially crafted custom
activation energy \(E_{a0} = - \phi \Delta G - E_a\), for which we
create a custom expression. To then construct homo- and
heterodimerization rules for all RAF paralogs, we use \texttt{itertools} to loop
over all combinations of BRAF and CRAF, implementing equal affinities for all homo- and heterodimers. For every rule we pass the custom energy
\(Ea_0\) and then specify an \texttt{EnergyPattern} for the single
product pattern (\texttt{pp}) with \(\Delta \Delta G_p = \Delta G\).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pysb} \PY{k+kn}{import} \PY{n}{Rule}\PY{p}{,} \PY{n}{EnergyPattern}
\PY{k+kn}{import} \PY{n+nn}{itertools} \PY{k}{as} \PY{n+nn}{itt}

\PY{n}{Expression}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Ea0\PYZus{}bind\PYZus{}RAF\PYZus{}RAF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
           \PY{o}{\PYZhy{}}\PY{n}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}phi}\PY{o}{*}\PY{n}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}dG} \PY{o}{\PYZhy{}} \PY{n}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}Ea}\PY{p}{)}\PY{p}{;}

\PY{k}{for} \PY{n}{RAF1}\PY{p}{,} \PY{n}{RAF2} \PY{o+ow}{in} \PY{n}{itt}\PY{o}{.}\PY{n}{combinations\PYZus{}with\PYZus{}replacement}\PY{p}{(}\PY{p}{[}\PY{n}{BRAF}\PY{p}{,} \PY{n}{CRAF}\PY{p}{]}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{:}
    \PY{n}{pp} \PY{o}{=} \PY{n}{RAF1}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAF2}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
    \PY{n}{Rule}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF1}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}and\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF2}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}bind\PYZus{}and\PYZus{}dissociate}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
         \PY{n}{RAF1}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)} \PY{o}{+} \PY{n}{RAF2}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)} \PY{o}{|} \PY{n}{pp}\PY{p}{,} 
         \PY{n}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}phi}\PY{p}{,} \PY{n}{Ea0\PYZus{}bind\PYZus{}RAF\PYZus{}RAF}\PY{p}{,} \PY{n}{energy}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
    \PY{n}{EnergyPattern}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}bind\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF1}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF2}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{pp}\PY{p}{,} \PY{n}{bind\PYZus{}RAF\PYZus{}RAF\PYZus{}dG}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{raf-inhibitor}{%
\subsection{RAF inhibitor}\label{raf-inhibitor}}

Next, we introduce a RAF inhibitor RAFi. We assume that the inhibitor is
added to the cell medium at some point and quickly diffuses in and out
of cells. As extracellular space is much bigger than the volume of a
cell, we can assume an infinite reservoir of molecules in the extracellular compartment
and assume that the intracellular inhibitors concentration will be
unaffected by intracellular reactions. Accordingly, we specify the
respective initial as fixed, which means that the respective
molecular species can participate in reactions, but it's concentration
will remain constant.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Monomer}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RAFi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{raf}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}

\PY{n}{Initial}\PY{p}{(}\PY{n}{RAFi}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)}\PY{p}{,} \PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RAFi\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{,} \PY{n}{fixed}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    Next we define binding reactions for RAFi with both BRAF and CRAF, again
implementing the same affinities and activation energies for both rules.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}Ea}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}dG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}phi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{Expression}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Ea0\PYZus{}bind\PYZus{}RAFi\PYZus{}RAF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
           \PY{o}{\PYZhy{}}\PY{n}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}phi}\PY{o}{*}\PY{n}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}dG} \PY{o}{\PYZhy{}} \PY{n}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}Ea}\PY{p}{)}

\PY{k}{for} \PY{n}{RAF} \PY{o+ow}{in} \PY{p}{[}\PY{n}{BRAF}\PY{p}{,} \PY{n}{CRAF}\PY{p}{]}\PY{p}{:}
    \PY{n}{Rule}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RAFi\PYZus{}and\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}bind\PYZus{}and\PYZus{}dissociate}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
         \PY{n}{RAFi}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)} \PY{o}{+} \PY{n}{RAF}\PY{p}{(}\PY{n}{rafi}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)} \PY{o}{|} \PY{n}{RAFi}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAF}\PY{p}{(}\PY{n}{rafi}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,} 
         \PY{n}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}phi}\PY{p}{,} \PY{n}{Ea0\PYZus{}bind\PYZus{}RAFi\PYZus{}RAF}\PY{p}{,} \PY{n}{energy}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
    \PY{n}{EnergyPattern}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}bind\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}RAFi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
                  \PY{n}{RAFi}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAF}\PY{p}{(}\PY{n}{rafi}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,} \PY{n}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}dG}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{paradoxical-activation}{%
\subsection{Paradoxical Activation}\label{paradoxical-activation}}

RAF inhibitors inhibit growth for BRAF mutants but promote growth for
RAS mutants. At the strucural level, this can be rationalized by
assuming that RAF inhibitors have higher affinity towards drug-unbound
RAF dimers and lower affinity towards drug bound RAF dimers. The
symmetry conveyed by energy conservation of molecular binding
reactions implies that RAF inhibitors,
promote dimerization at low to medium concentrations and incompletely inhibit signaling even at high concentrations, as they have lower affinity
 to the second protomer in a RAF dimer. As MAPK signaling for RAS
mutant cells is mediated by RAF dimers, respective signaling is
amplified, leading to increased growth. In the thermodynamic models,
this can be implemented by specifying additional \texttt{EnergyPattern}s
that controls the Gibbs free energy of $\mathrm{RAF}_2-\mathrm{RAFi}$ trimers. Note that
we do not specify how these trimers are formed, so the change in energy
will equally apply to the rates of all reactions that either consume or
produce these trimers. In this example, an decrease in energy would
equally increase RAF dimerization when exactly one protomer is inhibitor bound  and inhibitor binding to the first protomer in a dimer, thereby
implementing the previously described symmetry.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}RAFi\PYZus{}ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{k}{for} \PY{n}{RAF1}\PY{p}{,} \PY{n}{RAF2} \PY{o+ow}{in} \PY{n}{itt}\PY{o}{.}\PY{n}{product}\PY{p}{(}\PY{p}{[}\PY{n}{BRAF}\PY{p}{,} \PY{n}{CRAF}\PY{p}{]}\PY{p}{,} \PY{n}{repeat}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{:}
    \PY{n}{EnergyPattern}\PY{p}{(}
        \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF1}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF2}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}mod\PYZus{}RAFi\PYZus{}single}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
        \PY{n}{RAF1}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{rafi}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAF2}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{rafi}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAFi}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{,} 
        \PY{n}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}RAFi\PYZus{}ddG}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    To implement the lower affinity to the second protomer, we add an additional
\texttt{EnergyPattern} that changes the Gibbs free energy of
$\mathrm{RAF}_2-\mathrm{RAFi}_2$ tetramers.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Parameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}RAFi\PYZus{}RAFi\PYZus{}ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{k}{for} \PY{n}{RAF1}\PY{p}{,} \PY{n}{RAF2} \PY{o+ow}{in} \PY{n}{itt}\PY{o}{.}\PY{n}{combinations\PYZus{}with\PYZus{}replacement}\PY{p}{(}\PY{p}{[}\PY{n}{BRAF}\PY{p}{,} \PY{n}{CRAF}\PY{p}{]}\PY{p}{,} \PY{n}{r}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{:}
    \PY{n}{EnergyPattern}\PY{p}{(}
        \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF1}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{RAF2}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}mod\PYZus{}RAFi\PYZus{}double}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
        \PY{n}{RAFi}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAF1}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{rafi}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAF2}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{rafi}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{RAFi}\PY{p}{(}\PY{n}{raf}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,} 
        \PY{n}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}RAFi\PYZus{}RAFi\PYZus{}ddG}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    Here we note that these \texttt{EnergyPattern}s only specify that
changes in affinity are permissible in the model. The nature of these
changes has to be encoded in their values, where negative values lead to
stabilization and positive values to destabilization of respective
complexes.

    We will now load the remainder of the model from a file. Briefly, the
full model describes MEK and ERK phosphorylation downstream as well as
EGF stimulatable EGFR signaling upstream of RAF signaling. Moreover, it
incorporates negative feedback from ERK on both MAPK and EGFR signaling.
A comprehensive description of this part of the model is available in
\cite{2754712/I4JQ4DMV}. However, parts of the model were
substantially simplified account for the reduced set of experimental
data considered in this protocol. Specifically, description of EGFR signaling is removed and replaced by a phenomenological description, MEK inhibitors were removed from the model and two-step phosphorylation and dephosphorylation reactions were replaced by linear one-step reactions.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pysb} \PY{k+kn}{import} \PY{n}{Observable}\PY{p}{,} \PY{n}{ANY}
\PY{k}{def} \PY{n+nf}{extend\PYZus{}model}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    Content of this function is only included in the interactive notebook.

\PY{n}{extend\PYZus{}model}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{importing-data-in-petab-format}{%
\section{Importing data in PEtab
Format}\label{importing-data-in-petab-format}}

    With the model at hand, the next step for model calibration is
specification of the objective function \(\eqref{eq:objective}\). We
will specify the objective function using PEtab~\cite{2754712/86CV69R2},
which simplifies the definition of multiple experimental conditions. The
PEtab specification of a calibration problem consists of tables
describing model observables, experimental measurements, experimental
conditions and model parameters. Additionally, tables describing the
visualization of simulations and data may also be included.

    \hypertarget{observables}{%
\subsection{Observables}\label{observables}}

We will start the PEtab definition by specifying the model observables
\(\textbf{y}\) (see \(\eqref{eq:observable}\)). Observables define the
the model quantities that were measured experimentally, here pMEK and
pERK. First, we add respective observables to the model using PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Observable}{\texttt{Observable}}s:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{11}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Observable}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pMEK\PYZus{}obs}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{MEK}\PY{p}{(}\PY{n}{phospho}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{p}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
\PY{n}{Observable}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pERK\PYZus{}obs}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{ERK}\PY{p}{(}\PY{n}{phospho}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{p}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    These observables quantify all MEK (MAP2K1 + MAP2K2) and ERK (MAPK1 +
MAPK3) molecules that are phosphorylated on the site \texttt{phospho},
which accounts for phosphorylation on S218/S222 or S222/S226 on MEK and
T185/Y187 or T202/Y204 on ERK. These PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Observable}{\texttt{Observable}}s
define linear sums of model species \(\sum_i w_i x_i\), where \(w_i\) is
an integer that quantifies how often the specified pattern matches the
species \(x_i\).

Next, we construct the PEtab
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#observables-table}{\texttt{observables\ table}}.
The model quantifies pMEK and pERK in concentrations, but measurements
are noise corrupted, measured in fluorescence intensity and also include
background fluorescence. As the scaling between concentrations and
intensity and the amount of background signal is unknown, we include
scaling and offset parameters in the PEtab observable definition
\texttt{petab.OBSERVABLE\_FORMULA}, which specifies the observable
function \(g_i\) (see \(\eqref{eq:observable}\)). To account for noise
corruption, we specify a single noise parameter \(\psi_i\) as PEtab
noise formula \texttt{petab.NOISE\_FORMULA}, which corresponds to a 
Gaussian (default when no \texttt{petab.NOISE\_DISTRIBUTION} is
specified) distribution, with the respective parameter as standard
deviation \(\sigma_i\) (see \(\eqref{eq:noise}\)). The prefix
\texttt{noiseParameter1} indicates that the value of the parameter will
be provided in the respective column of the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#measurement-table}{\texttt{measurement\ table}},
which permits the specification of timepoint and condition specific
noise levels via \(\Psi_{ijk}\) (see \(\eqref{eq:objective}\)).
Here, the specified observable formula \(g_i\) does not include any
explicit PEtab noise parameters. However, the scale and offset
parameters for each observable could be replaced by
\texttt{observableParameter{[}0-9{]}+} placeholders, which would enable
the designation of timepoint and condition specific values in the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#measurement-table}{\texttt{measurement\ table}}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{12}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{petab}
\PY{k+kn}{import} \PY{n+nn}{pandas} \PY{k}{as} \PY{n+nn}{pd}
\PY{n}{observables\PYZus{}table} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{[}
    \PY{p}{\PYZob{}}
        \PY{n}{petab}\PY{o}{.}\PY{n}{OBSERVABLE\PYZus{}ID}\PY{p}{:} \PY{n}{obs\PYZus{}id}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{OBSERVABLE\PYZus{}FORMULA}\PY{p}{:} 
            \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{obs\PYZus{}id}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}scale*}\PY{l+s+si}{\PYZob{}}\PY{n}{obs\PYZus{}id}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}obs + }\PY{l+s+si}{\PYZob{}}\PY{n}{obs\PYZus{}id}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}offset}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{NOISE\PYZus{}FORMULA}\PY{p}{:} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{noiseParameter1\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{obs\PYZus{}id}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}
    \PY{p}{\PYZcb{}} \PY{k}{for} \PY{n}{obs\PYZus{}id} \PY{o+ow}{in} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pMEK}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pERK}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
\PY{p}{]}\PY{p}{)}\PY{o}{.}\PY{n}{set\PYZus{}index}\PY{p}{(}\PY{n}{petab}\PY{o}{.}\PY{n}{OBSERVABLE\PYZus{}ID}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{measurements-and-conditions}{%
\subsection{Measurements and
Conditions}\label{measurements-and-conditions}}

As experimental measurements, we will load one of the datasets from \cite{2754712/I4JQ4DMV},
which contains the response of A375 cells cultured for 24h at different
concentrations of multiple RAF and MEK inhibitors. The response is
measured as normalized phospho-MEK (pMEK) and phospho-ERK (pERK)
abundances in unstimulated cells and in EGF stimulated cells 5
minutes after stimulation.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{13}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{synapseclient} \PY{k}{as} \PY{n+nn}{sc}

\PY{n}{syn} \PY{o}{=} \PY{n}{sc}\PY{o}{.}\PY{n}{Synapse}\PY{p}{(}\PY{p}{)}
\PY{n}{syn}\PY{o}{.}\PY{n}{login}\PY{p}{(}\PY{n}{silent}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}\PY{p}{;}
\PY{n}{data\PYZus{}df} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{read\PYZus{}csv}\PY{p}{(}\PY{n}{syn}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{syn22804081}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{path}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}
        
    The data contains the dose response to multiple RAF and MEK inhibitors as
well as respective combinations. However, to minimize computation time
requirements, we will only consider data involving the two RAFis
vemurafenib and dabrafenib. The model itself only contains generic
\texttt{RAFi} parameters and species, which we can now map to specific
inhibitors using experimental conditions. This permits the simultaneous
estimation of inhibitor specific kinetic rates in conjunction with all
other model parameters. Such an multi-experiment setup can improve
parameter identifiability.

In the following, we will simulatenously generate the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#condition-table}{\texttt{condition\ table}},
encoding the condition specific mapping \(\boldsymbol{\Gamma}_k\) (see
\(\eqref{eq:objective}\)) of dynamic paramers \(\boldsymbol{\gamma}\)
(see \(\eqref{eq:ode}\)), and
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#measurement-table}{\texttt{measurement\ table}},
encoding measurements \(\bar{\textbf{y}} _{ijk}\) and, potentially,
respective mappings for observable parameters \(\boldsymbol{\xi}\) (see
\(\eqref{eq:observable}\)) via \(\boldsymbol{\Xi}_{ijk}\) (see
\(\eqref{eq:objective}\)) and noise parameters \(\boldsymbol{\psi}\)
(see \(\eqref{eq:noise}\)) via \(\boldsymbol{\Psi}_{ijk}\) (see
\(\eqref{eq:objective}\)). The
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#condition-table}{\texttt{condition\ table}}
describes the necessary information about experimentel conditions, i.e.,
what drug was used and what concentrations were applied. The
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#measurement-table}{\texttt{measurement\ table}}
describes the measurement itself as well as additional information, such
as under which experimental conditions the data was measured.

The data we loaded above is in a matrix format, while PEtab requires the
data a long format. Thus, additional processing is necessary. Briefly,
the code below extracts all data points and sets what model observable
they belong to (\texttt{petab.OBSERVABLE\_ID}), the value of the measurement (\texttt{petab.MEASUREMENT}), the time of measurement (\texttt{petab.TIME}),
the noise parameter (\texttt{petab.NOISE\_PARAMETERS}) and information about the experimental condition.

For the EGF stimulation condition, it is important to consider the
experimental setup, as cells are subjected to 24h of pretreatment with
drugs. We here assume that this is sufficient time for the system to
reach a steady-state. To describe such an experimental setup in PEtab,
it is necessary to reference the respective experimental condition in
the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#condition-table}{\texttt{condition\ table}}
by specifying the respective \texttt{petab.CONDITION\_ID} in the
\texttt{petab.PREEQUILIBRATION\_CONDITION\_ID} column. The condition for
the actual experiment can then be specified in the
\texttt{petab.SIMULATION\_CONDITION\_ID}.

To enable the visualization of data and fitting results, we here also
specify the \texttt{petab.DATASET\_ID}. Tis does not influence the actual fitting, but serves as
grouping identifier during visualization.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{14}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{RAFis} \PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Vemurafenib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Dabrafenib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{PLX8394}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{LY3009120}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{AZ\PYZus{}628}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
\PY{n}{MEKis} \PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Cobimetinib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Trametinib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Selumetinib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Binimetinib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{PD0325901}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}


\PY{n}{conditions} \PY{o}{=} \PY{n+nb}{dict}\PY{p}{(}\PY{p}{)}


\PY{k}{def} \PY{n+nf}{format\PYZus{}petab}\PY{p}{(}\PY{n}{row}\PY{p}{)}\PY{p}{:}
    \PY{n}{suffixes} \PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{+} \PY{p}{[}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{.}\PY{l+s+si}{\PYZob{}}\PY{n}{idx}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}} \PY{k}{for} \PY{n}{idx} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{]}
    \PY{n}{datapoints} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{k}{if} \PY{n}{row}\PY{p}{[}\PY{n}{MEKis}\PY{p}{]}\PY{o}{.}\PY{n}{any}\PY{p}{(}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n}{datapoints}
    \PY{c+c1}{\PYZsh{} loop over columns of the data matrix}
    \PY{k}{for} \PY{n}{suffix} \PY{o+ow}{in} \PY{n}{suffixes}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} extract data}
        \PY{n}{datapoint} \PY{o}{=} \PY{p}{\PYZob{}}
            \PY{n}{petab}\PY{o}{.}\PY{n}{OBSERVABLE\PYZus{}ID}\PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pMEK}\PY{l+s+s1}{\PYZsq{}} \PY{k}{if} \PY{n}{row}\PY{o}{.}\PY{n}{pMEK} \PY{k}{else} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pERK}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
            \PY{n}{petab}\PY{o}{.}\PY{n}{MEASUREMENT}\PY{p}{:} \PY{n}{row}\PY{p}{[}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Mean}\PY{l+s+si}{\PYZob{}}\PY{n}{suffix}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
            \PY{n}{petab}\PY{o}{.}\PY{n}{TIME}\PY{p}{:} \PY{n}{row}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Time\PYZus{}EGF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
            \PY{n}{petab}\PY{o}{.}\PY{n}{NOISE\PYZus{}PARAMETERS}\PY{p}{:} \PY{n}{row}\PY{p}{[}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Std}\PY{l+s+si}{\PYZob{}}\PY{n}{suffix}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
        \PY{p}{\PYZcb{}}
        \PY{c+c1}{\PYZsh{} extract condition information}
        \PY{k}{if} \PY{p}{(}\PY{n}{row}\PY{p}{[}\PY{n}{RAFis}\PY{p}{]} \PY{o}{!=} \PY{l+m+mi}{0}\PY{p}{)}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{p}{)} \PY{o}{!=} \PY{l+m+mi}{1} \PY{o+ow}{or} \PYZbs{}
                \PY{p}{(}\PY{p}{(}\PY{n}{row}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Vemurafenib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{)} \PY{o+ow}{and} \PY{p}{(}\PY{n}{row}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Dabrafenib}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{)}\PY{p}{)}\PY{p}{:}
            \PY{k}{continue}

        \PY{c+c1}{\PYZsh{} find first nonzero}
        \PY{n}{rafi} \PY{o}{=} \PY{n}{RAFis}\PY{p}{[}\PY{p}{(}\PY{n}{row}\PY{p}{[}\PY{n}{RAFis}\PY{p}{]} \PY{o}{!=} \PY{l+m+mi}{0}\PY{p}{)}\PY{o}{.}\PY{n}{argmax}\PY{p}{(}\PY{p}{)}\PY{p}{]}

        \PY{c+c1}{\PYZsh{} extract drug concentration}
        \PY{n}{drug\PYZus{}conc} \PY{o}{=} \PY{n}{row}\PY{p}{[}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Concentration (uM)}\PY{l+s+si}{\PYZob{}}\PY{n}{suffix}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{k}{if} \PY{n}{row}\PY{p}{[}\PY{n}{rafi}\PY{p}{]} \PY{o}{==} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1} \PYZbs{}
            \PY{k}{else} \PY{n}{row}\PY{p}{[}\PY{n}{rafi}\PY{p}{]}
        \PY{c+c1}{\PYZsh{} condition id must be sanitzed, must match \PYZsq{}\PYZca{}[a\PYZhy{}zA\PYZhy{}Z]+[\PYZbs{}w\PYZus{}]*\PYZdl{}\PYZsq{}}
        \PY{n}{drug\PYZus{}str} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{rafi}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{drug\PYZus{}conc}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{.}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZhy{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

        \PY{n}{condition\PYZus{}str} \PY{o}{=} \PY{n}{drug\PYZus{}str} \PY{o}{+} \PY{p}{(}
            \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}EGF\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{row}\PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{EGF}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}} \PY{k}{if} \PY{n}{row}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{EGF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0} \PY{k}{else} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}
        \PY{p}{)}
        \PY{n}{condition} \PY{o}{=} \PY{p}{\PYZob{}}
            \PY{n}{petab}\PY{o}{.}\PY{n}{CONDITION\PYZus{}ID}\PY{p}{:} \PY{n}{condition\PYZus{}str}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RAFi\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{drug\PYZus{}conc}\PY{p}{,}
            \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{EGF\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{row}\PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{EGF}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}Ea}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{rafi}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}RAF\PYZus{}Ea}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
            \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}RAFi\PYZus{}RAF\PYZus{}dG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bind\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{rafi}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}RAF\PYZus{}dG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
            \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}RAFi\PYZus{}ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{rafi}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
            \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}RAFi\PYZus{}RAFi\PYZus{}ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ep\PYZus{}RAF\PYZus{}RAF\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{rafi}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{rafi}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}ddG}\PY{l+s+s1}{\PYZsq{}}
        \PY{p}{\PYZcb{}}
        \PY{c+c1}{\PYZsh{} set baseline for datapoint}
        \PY{n}{datapoint}\PY{p}{[}\PY{n}{petab}\PY{o}{.}\PY{n}{PREEQUILIBRATION\PYZus{}CONDITION\PYZus{}ID}\PY{p}{]} \PY{o}{=} \PY{n}{drug\PYZus{}str}
        \PY{c+c1}{\PYZsh{} set id for condition and datapoint}
        \PY{n}{datapoint}\PY{p}{[}\PY{n}{petab}\PY{o}{.}\PY{n}{SIMULATION\PYZus{}CONDITION\PYZus{}ID}\PY{p}{]} \PY{o}{=} \PY{n}{condition\PYZus{}str}
        \PY{n}{datapoint}\PY{p}{[}\PY{n}{petab}\PY{o}{.}\PY{n}{DATASET\PYZus{}ID}\PY{p}{]} \PY{o}{=}  \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{EGF\PYZus{}\PYZus{}}\PY{l+s+s1}{\PYZsq{}} \PY{k}{if} \PY{n}{row}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{EGF}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0} \PYZbs{}
                                        \PY{k}{else} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ctrl\PYZus{}\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{rafi}
        \PY{n}{condition}\PY{p}{[}\PY{n}{petab}\PY{o}{.}\PY{n}{CONDITION\PYZus{}ID}\PY{p}{]} \PY{o}{=} \PY{n}{condition\PYZus{}str}
        
        \PY{n}{datapoints}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{datapoint}\PY{p}{)}
        \PY{k}{if} \PY{n}{condition\PYZus{}str} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{conditions}\PY{p}{:}
            \PY{n}{conditions}\PY{p}{[}\PY{n}{condition\PYZus{}str}\PY{p}{]} \PY{o}{=} \PY{n}{condition}
            
    \PY{k}{return} \PY{n}{datapoints}

\PY{n}{measurement\PYZus{}table} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{[}
    \PY{n}{d}
    \PY{k}{for} \PY{n}{ir}\PY{p}{,} \PY{n}{row} \PY{o+ow}{in} \PY{n}{data\PYZus{}df}\PY{o}{.}\PY{n}{iterrows}\PY{p}{(}\PY{p}{)}
    \PY{k}{for} \PY{n}{d} \PY{o+ow}{in} \PY{n}{format\PYZus{}petab}\PY{p}{(}\PY{n}{row}\PY{p}{)}
\PY{p}{]}\PY{p}{)}
\PY{n}{condition\PYZus{}table} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{n}{conditions}\PY{o}{.}\PY{n}{values}\PY{p}{(}\PY{p}{)}\PY{p}{)}\PY{o}{.}\PY{n}{set\PYZus{}index}\PY{p}{(}\PY{n}{petab}\PY{o}{.}\PY{n}{CONDITION\PYZus{}ID}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    In the above code we extracted experimentally measured standard
deviations, which can be noisy as they are often computed from a small
number of biological or technical replicates. As the magnitude of
standard deviations determines the importance of datapoints during
calibration, outliers can lead to overemphasis or ignorance of
individual datapoints, resulting in poor fits to the overall data. To
avoid such issues, we use the same averaged standard deviations for all
datapoints of each observable. For averaging we compute the root mean
square, as variances are additive, but standard deviations are not.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{15}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{k}{for} \PY{n}{group}\PY{p}{,} \PY{n}{frame} \PY{o+ow}{in} \PY{n}{measurement\PYZus{}table}\PY{o}{.}\PY{n}{groupby}\PY{p}{(}\PY{n}{petab}\PY{o}{.}\PY{n}{OBSERVABLE\PYZus{}ID}\PY{p}{)}\PY{p}{:}
    \PY{n}{measurement\PYZus{}table}\PY{o}{.}\PY{n}{loc}\PY{p}{[}\PY{n}{measurement\PYZus{}table}\PY{p}{[}\PY{n}{petab}\PY{o}{.}\PY{n}{OBSERVABLE\PYZus{}ID}\PY{p}{]}\PY{o}{==}\PY{n}{group}\PY{p}{,} 
                          \PY{n}{petab}\PY{o}{.}\PY{n}{NOISE\PYZus{}PARAMETERS}\PY{p}{]} \PY{o}{=} \PYZbs{}
        \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{frame}\PY{p}{[}\PY{n}{petab}\PY{o}{.}\PY{n}{NOISE\PYZus{}PARAMETERS}\PY{p}{]}\PY{o}{.}\PY{n}{apply}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{square}\PY{p}{)}\PY{o}{.}\PY{n}{mean}\PY{p}{(}\PY{p}{)}\PY{p}{);}
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{parameters}{%
\subsection{Parameters}\label{parameters}}

The last table necessary for model training is the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#parameter-table}{\texttt{parameter\ table}}.
This table describes all free parameters \(\boldsymbol{\theta}\) (\texttt{petab.PARAMETER\_ID}),
whether they have to be estimated (\texttt{petab.ESTIMATE}) as well as their scale (\texttt{petab.PARAMETER\_SCALE}), nominal
values (\texttt{petab.NOMINAL\_VALUE}), boundary values \(\mathcal{L}_l\) (\texttt{petab.LOWER\_BOUND}) and \(\mathcal{U}_l\) (\texttt{petab.UPPER\_BOUND}) and
information about priors.

Both parameter boundaries and priors can be used to restrict the search
space to biologically plausible parameter values, or prevent numerical
issues in regions of parameter space where numerical integration of
model equations is challenging. Parameter boundaries set hard thresholds
that cannot be exceeded, while parameter boundaries are soft constraints
that also regularize the calibration. While priors are necessary for
Bayesian analysis such as parameter sampling, they are not generally
required for optimization based approaches.

For most models, free parameters \(\boldsymbol{\theta}\) will primarily
occur in the model specification as dynamic parameters
\(\boldsymbol{\gamma}\). But, all of previously described tables may
introduce new free parameters: noise parameters \(\boldsymbol{\psi}\) in
noise formulas \(\boldsymbol{\sigma}\) or respective condition specific
mappings \(\boldsymbol{\Psi}_{ijk}\), observable paramers
\(\boldsymbol{\xi}\) in observable formulas \(\boldsymbol{g}\) or
respective condition specific mappings \(\boldsymbol{\Xi}_{ijk}\) as
well as the condition specific dynamic parameter mappings
\(\boldsymbol{\Gamma}_{k}\). Moreover, the respective tables, i.e., the
respective mappings \(\boldsymbol{\Psi}_{ijk}\),
\(\boldsymbol{\Xi}_{ijk}\) and \(\boldsymbol{\Gamma}_{k}\) may set
numerical values for the noise, observable and dynamic parameters,
rendering them non-free. As the parameter table must only describe free
parameters \(\boldsymbol{\theta}\), some processing is usually necessary
to identify free and non-free parameters.

In the following, we will construct a list of \texttt{condition\_pars},
which are either mapped to free, condition-specific parameters, such as
the generic RAFi energy parameters, or set to non-free parameters with
fixed numeric values, such as the \texttt{RAFi\_0} initial
concentration. To construct the list of free parameters, we identify all
dynamic parameters in the model that are not contained in these
\texttt{condition\_pars}, and add all newly introduced condition
specific parameters in the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#condition-table}{\texttt{condition\ table}}
as well as the four offset and scaling parameters we introduced in the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#observables-table}{\texttt{observables\ table}}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{17}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{n}{condition\PYZus{}pars} \PY{o}{=} \PY{p}{[}
    \PY{n}{par}\PY{o}{.}\PY{n}{name}
    \PY{k}{for} \PY{n}{par} \PY{o+ow}{in} \PY{n}{model}\PY{o}{.}\PY{n}{parameters}
    \PY{k}{if} \PY{n}{par}\PY{o}{.}\PY{n}{name} \PY{o+ow}{in} \PY{n}{condition\PYZus{}table}\PY{o}{.}\PY{n}{columns}
\PY{p}{]}

\PY{n}{free\PYZus{}parameters} \PY{o}{=} \PY{p}{[}
    \PY{n}{par}\PY{o}{.}\PY{n}{name} \PY{k}{for} \PY{n}{par} \PY{o+ow}{in} \PY{n}{model}\PY{o}{.}\PY{n}{parameters}
    \PY{k}{if} \PY{n}{par}\PY{o}{.}\PY{n}{name} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{condition\PYZus{}pars}
\PY{p}{]} \PY{o}{+} \PY{p}{[}
    \PY{n}{name}
    \PY{k}{for} \PY{n}{par} \PY{o+ow}{in} \PY{n}{condition\PYZus{}pars}
    \PY{k}{for} \PY{n}{name} \PY{o+ow}{in} \PY{n}{np}\PY{o}{.}\PY{n}{unique}\PY{p}{(}\PY{n}{condition\PYZus{}table}\PY{p}{[}\PY{n}{par}\PY{p}{]}\PY{p}{)}
    \PY{k}{if} \PY{n+nb}{isinstance}\PY{p}{(}\PY{n}{name}\PY{p}{,} \PY{n+nb}{str}\PY{p}{)}
\PY{p}{]} \PY{o}{+} \PY{p}{[}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pMEK\PYZus{}offset}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pMEK\PYZus{}scale}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pERK\PYZus{}offset}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pERK\PYZus{}scale}\PY{l+s+s1}{\PYZsq{}}
\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

    All of the parameters in the model follow a consistent naming scheme,
which makes it easier to programmatically specify parameter boundaries,
scales and whether parameters are to be estimated. Multiple studies have
demonstrated that parameter estimation is more efficient when estimating
parameters on a logarithmic scale
\cite{2754712/INKV577L,2754712/FMD3RVCR}. Yet, the thermodynamic
formulation we employed for model construction relies on an exponential
dependency between energies and kinetetic rates, which complements these
practical insights with a theoretical foundation why a logarithmic scale is more natural. However, this also suggests that energetic
parameters, in contrast to kinetic rates, should be estimated on a
linear scale.

The upper and lower boundaries should ideally be set to biologically
plausible values. However, most models employ simplified descriptions of
the underlying biochemical processes, which means that model parameters
may no longer have a one-to-one correspondance to true biochemical
constants and plausible parameter ranges may be difficult to derive.
Moreover, plausible parameter ranges may not be known for all
parameters. Therefore, in many applications parameter boundaries are
initially based on educated guesses and then refined based on estimation
results such that optima are contained in the specified ranges and
integration failures are not too frequent. Therefore, the boundaries
presented here are based on the values used in the original publication~\cite{2754712/I4JQ4DMV}
and where then refined to work with the simplified model.

Similar to parameter boundaries, nominal values can be difficult to
derive. However, the numerical values are only important for model
calibration when respective parameters are not estimated. In this
example, we do not estimate the initial concentrations and \(\phi\)
parameters and only set the nominal parameter values of those parameters
to non-trivial values. The initial concentrations are set to approximate
molecular counts as measured in the original publication and \(\phi\)
parameters are all set to 1, meaning that free energy differences only
affect the reverse rate.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{18}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{lbs} \PY{o}{=} \PY{p}{\PYZob{}}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Ea}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{o}{\PYZhy{}}\PY{l+m+mi}{8}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{dG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{o}{\PYZhy{}}\PY{l+m+mi}{8}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{o}{\PYZhy{}}\PY{l+m+mi}{8}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{phi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{offset}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{5e\PYZhy{}2}\PY{p}{,}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{scale}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e0}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{eq}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e1}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e3}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kcat}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e\PYZhy{}2}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{gexpslope}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e0}\PY{p}{,}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kdeg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e\PYZhy{}3}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kM}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e\PYZhy{}3}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kcatr}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e\PYZhy{}5}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{koff}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e\PYZhy{}5}\PY{p}{,}
\PY{p}{\PYZcb{}}
\PY{n}{ubs} \PY{o}{=} \PY{p}{\PYZob{}}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Ea}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{dG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{phi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{offset}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{2e\PYZhy{}1}\PY{p}{,}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{scale}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e6}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{eq}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e5}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e5}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kcat}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e5}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{gexpslope}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e6}\PY{p}{,}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kdeg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e2}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kM}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e1}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{kcatr}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e2}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{koff}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e0}\PY{p}{,}
\PY{p}{\PYZcb{}}

\PY{n}{initials} \PY{o}{=} \PY{p}{\PYZob{}}
    \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{BRAF\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e3}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{CRAF\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e4}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{MEK\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e5}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ERK\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{1e5}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RAS\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mf}{5e4}\PY{p}{,}
\PY{p}{\PYZcb{}}


\PY{n}{parameter\PYZus{}table} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{[}
    \PY{p}{\PYZob{}}
        \PY{n}{petab}\PY{o}{.}\PY{n}{PARAMETER\PYZus{}ID}\PY{p}{:} \PY{n}{par}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{PARAMETER\PYZus{}SCALE}\PY{p}{:} \PY{n}{petab}\PY{o}{.}\PY{n}{LIN} 
        \PY{k}{if} \PY{n}{par}\PY{o}{.}\PY{n}{endswith}\PY{p}{(}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}Ea}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}dG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}ddG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}phi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)} \PY{k}{else} \PY{n}{petab}\PY{o}{.}\PY{n}{LOG10}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{LOWER\PYZus{}BOUND}\PY{p}{:} \PY{n}{lbs}\PY{p}{[}\PY{n}{par}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{UPPER\PYZus{}BOUND}\PY{p}{:} \PY{n}{ubs}\PY{p}{[}\PY{n}{par}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{NOMINAL\PYZus{}VALUE}\PY{p}{:} \PY{n}{initials}\PY{p}{[}\PY{n}{par}\PY{p}{]} \PY{k}{if} \PY{n}{par}\PY{o}{.}\PY{n}{endswith}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{k}{else} \PY{l+m+mf}{1.0}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{ESTIMATE}\PY{p}{:} \PY{k+kc}{False} \PY{k}{if} \PY{n}{par}\PY{o}{.}\PY{n}{endswith}\PY{p}{(}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}phi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)} \PY{k}{else} \PY{k+kc}{True}\PY{p}{,}
        
    \PY{p}{\PYZcb{}} \PY{k}{for} \PY{n}{par} \PY{o+ow}{in} \PY{n}{free\PYZus{}parameters}
\PY{p}{]}\PY{p}{)}\PY{o}{.}\PY{n}{set\PYZus{}index}\PY{p}{(}\PY{n}{petab}\PY{o}{.}\PY{n}{PARAMETER\PYZus{}ID}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{sbml-export}{%
\subsection{SBML export}\label{sbml-export}}

PEtab expects a model in SBML format, but we constructed the model in
the PySB/BNGL format. Therefore, we need to export the model in SBML format.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{19}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{libsbml}
\PY{k+kn}{from} \PY{n+nn}{pysb}\PY{n+nn}{.}\PY{n+nn}{export} \PY{k+kn}{import} \PY{n}{export}
\PY{n}{sbml\PYZus{}reader} \PY{o}{=} \PY{n}{libsbml}\PY{o}{.}\PY{n}{SBMLReader}\PY{p}{(}\PY{p}{)}
\PY{n}{sbml\PYZus{}doc} \PY{o}{=} \PY{n}{sbml\PYZus{}reader}\PY{o}{.}\PY{n}{readSBMLFromString}\PY{p}{(}\PY{n}{export}\PY{p}{(}\PY{n}{model}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{sbml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
\PY{n}{sbml\PYZus{}model} \PY{o}{=} \PY{n}{sbml\PYZus{}doc}\PY{o}{.}\PY{n}{getModel}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    In the SBML model, PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Observable}{\texttt{Observable}}s
are exported as SBML \href{http://model.caltech.edu/software/libsbml/5.18.0/docs/formatted/python-api/classlibsbml_1_1_parameter.html}{\texttt{Parameter}}s and \href{http://model.caltech.edu/software/libsbml/5.18.0/docs/formatted/python-api/classlibsbml_1_1_assignment_rule.html}{\texttt{AssignmentRule}}s, with
programmatically generated identifiers that do not match the PySB
\href{https://pysb.readthedocs.io/en/stable/modules/core.html\#pysb.core.Observable}{\texttt{Observable}}
identifiers. As we referenced these observable names when specifying the PEtab
observables, we have to change the SBML identifiers to
match the PySB identifier. These changes have to be applied to the SBML
\href{http://model.caltech.edu/software/libsbml/5.18.0/docs/formatted/python-api/classlibsbml_1_1_parameter.html}{\texttt{Parameter}}
as well as the SBML
\href{http://model.caltech.edu/software/libsbml/5.18.0/docs/formatted/python-api/classlibsbml_1_1_assignment_rule.html}{\texttt{AssignmentRule}}
that sets their value.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{20}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} rename pysb exported observables}
\PY{n}{sbml\PYZus{}model}\PY{o}{.}\PY{n}{getParameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}obs1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{setId}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pMEK\PYZus{}obs}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{sbml\PYZus{}model}\PY{o}{.}\PY{n}{getAssignmentRuleByVariable}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}obs1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{setVariable}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pMEK\PYZus{}obs}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{sbml\PYZus{}model}\PY{o}{.}\PY{n}{getParameter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}obs2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{setId}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pERK\PYZus{}obs}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{sbml\PYZus{}model}\PY{o}{.}\PY{n}{getAssignmentRuleByVariable}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}obs2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{setVariable}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pERK\PYZus{}obs}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    As last step, we create a PEtab
\href{https://petab.readthedocs.io/projects/libpetab-python/en/latest/build/_autosummary/petab.problem.html\#petab.problem.Problem}{\texttt{Problem}}
using all of the previously constructed tables as well as the exported
SBML model. As problem construction was a lengthy, error-prone process,
we perform a static analysis of the petab problem using the petab
library provided linter
\href{https://petab.readthedocs.io/projects/libpetab-python/en/latest/build/_autosummary/petab.html\#petab.lint_problem}{\texttt{petab.lint\_problem}}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{21}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{petab}
\PY{n}{petab\PYZus{}problem} \PY{o}{=} \PY{n}{petab}\PY{o}{.}\PY{n}{Problem}\PY{p}{(}
    \PY{n}{sbml\PYZus{}model}\PY{o}{=}\PY{n}{sbml\PYZus{}model}\PY{p}{,} \PY{n}{sbml\PYZus{}reader}\PY{o}{=}\PY{n}{sbml\PYZus{}reader}\PY{p}{,} \PY{n}{sbml\PYZus{}document}\PY{o}{=}\PY{n}{sbml\PYZus{}doc}\PY{p}{,}
    \PY{n}{measurement\PYZus{}df}\PY{o}{=}\PY{n}{measurement\PYZus{}table}\PY{p}{,} \PY{n}{condition\PYZus{}df}\PY{o}{=}\PY{n}{condition\PYZus{}table}\PY{p}{,}
    \PY{n}{observable\PYZus{}df}\PY{o}{=}\PY{n}{observables\PYZus{}table}\PY{p}{,} \PY{n}{parameter\PYZus{}df}\PY{o}{=}\PY{n}{parameter\PYZus{}table}
\PY{p}{)}
\PY{n}{petab}\PY{o}{.}\PY{n}{lint}\PY{o}{.}\PY{n}{lint\PYZus{}problem}\PY{p}{(}\PY{n}{petab\PYZus{}problem}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{calibrating-the-model-in-pypesto}{%
\section{Calibrating the model in
pyPESTO}\label{calibrating-the-model-in-pypesto}}

Model calibration based on PEtab \cite{2754712/86CV69R2} format is
supported by a growing number of tools, including COPASI
\cite{2754712/I9T5NNAF} and data2dynamics \cite{2754712/RYRYBYZA}. Here
we used the python based calibration tool pyPESTO for calibration.
pyPESTO uses AMICI \cite{2754712/HBAI2XHJ} for model import and
simulation, constructs functions to evaluate the objective function
\(J(\boldsymbol{\theta})\) and it's gradient
\(\nabla_{\boldsymbol{\theta}}J(\boldsymbol{\theta})\) and provides an
interface to a plethora of different optimizers.

To facilitate efficient evaluation of the objective function and it's
derivatives, we will first compile the model in AMICI. Model compilation
should take about a minute on modern desktop machines, but ensures that
numerical solutions \(\textbf{x}\) and their sensitivies
\(\nabla_{\boldsymbol{\gamma}}\textbf{x}\), which are required for the
evaluation of \(\nabla_{\boldsymbol{\theta}}J(\boldsymbol{\theta})\),
are computed using the SUNDIALS solver suite \cite{2754712/YDMLXLFR}.
AMICI compilation is automatically triggered by calling the
\href{https://pypesto.readthedocs.io/en/latest/api_petab.html\#pypesto.petab.PetabImporter.create_problem}{\texttt{create\_problem}}
method of a pypesto
\href{https://pypesto.readthedocs.io/en/latest/api_petab.html\#pypesto.petab.PetabImporter}{\texttt{PetabImporter}}
instance.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{22}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{pypesto}
\PY{k+kn}{import} \PY{n+nn}{pypesto}\PY{n+nn}{.}\PY{n+nn}{petab}
\PY{n}{importer} \PY{o}{=} \PY{n}{pypesto}\PY{o}{.}\PY{n}{petab}\PY{o}{.}\PY{n}{PetabImporter}\PY{p}{(}\PY{n}{petab\PYZus{}problem}\PY{p}{,}
                                       \PY{n}{model\PYZus{}name}\PY{o}{=}\PY{n}{model}\PY{o}{.}\PY{n}{name}\PY{p}{)}

\PY{n}{pypesto\PYZus{}problem} \PY{o}{=} \PY{n}{importer}\PY{o}{.}\PY{n}{create\PYZus{}problem}\PY{p}{(}\PY{n}{force\PYZus{}compile}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}


    Simulations in AMICI are highly customizable and many steps,
including everything that was specified in the the PEtab problem, are
automated by pypesto. Yet, not all options are set automatically and some
user input may be required. For example, the considered example includes
preequilibrations (specified by \texttt{petab.PREEQUILIBRATION\_CONDITION\_ID}) which are automatically handled by pyPESTO and AMICI.
However, AMICI supports multiple different methods to compute
steady-states as well as respective sensitivities. By default, a
combination of Newton's method and simulation is employed to approximate
the steadystate \cite{2754712/LVNQBT95}. To find a steadystate by
Newton's method, the Newton-Raphson algorithm is applied to the
rootfinding problem

\[ \{\textbf{x}: \textbf{f}(t,\textbf{x},\boldsymbol{\gamma}) = 0\}. \]

In contrast, the simulation based approach numerically integrates
\(\eqref{eq:ode}\) until \(\textbf{f}\) is sufficiently small with
respect to some norm. For both approaches, AMICI uses a convergence
criterium based on a combination of absolute and relative tolerances,
similar to error control during numerical integration:

\[ \sum_i^{\dims{x}} \frac{f_i(t,\textbf{x},\boldsymbol{\gamma})}{a + r x_i} < 1\]

where \(a\) and \(r\) are absolute and relative tolerances that can be
set via the
\href{https://amici.readthedocs.io/en/latest/generated/amici.amici.Solver.html\#amici.amici.Solver}{\texttt{Solver}}
methods
\href{https://amici.readthedocs.io/en/latest/generated/amici.amici.Solver.html\#amici.amici.Solver.setAbsoluteToleranceSteadyState}{\texttt{setAbsoluteToleranceSteadyState}}
and
\href{https://amici.readthedocs.io/en/latest/generated/amici.amici.Solver.html\#amici.amici.Solver.setRelativeToleranceSteadyState}{\texttt{setRelativeToleranceSteadyState}}
respectively. In both cases, sensitivites
\(\nabla_{\boldsymbol{\gamma}}\textbf{x}_{ss}\) of the steadystate
\(\textbf{x}_{ss}\) can be computed using the Implicit Function Theorem
(IFT) \cite{2754712/6AWGLSM9}, which is the most efficient option when
applicable:

\[ \nabla_{\boldsymbol{\gamma}}\textbf{x}_{ss} = \nabla_x\textbf{f}(t,\textbf{x}_{ss},\boldsymbol{\gamma})^{-1}\nabla_{\boldsymbol{\gamma}}\textbf{f}(t,\textbf{x}_{ss},\boldsymbol{\gamma}) . \]

However, sensitivity computation via the IFT requires that the Jacobian
\(\nabla_x\textbf{f}(t,\textbf{x}_{ss},\boldsymbol{\gamma})\) is not
singular, which is, for example, not the case for models with
conservation laws. More details about preequilibration in AMICI is
available in the
\href{https://amici.readthedocs.io/en/latest/ExampleEquilibrationLogic.html}{\texttt{online\ documentation}}.

As the model we constructed does not account for protein synthesis and
degradation, total protein abundances are conserved quantities in the
model and the IFT is not applicable. Thus, we here employ a purely
simulation based steadystate search, by setting the allowed newton steps
to 0, and compute the steadystate sensitivities using forward
sensitivity analysis, by setting the steadystate sensitivity mode
accordingly. To apply these options during optimization, we set these
options in the AMICI
\href{https://amici.readthedocs.io/en/latest/generated/amici.amici.Solver.html\#amici.amici.Solver}{\texttt{Solver}}
and
\href{https://amici.readthedocs.io/en/latest/generated/amici.amici.Model.html\#amici.amici.Model}{\texttt{Model}}
instances of the
\href{https://pypesto.readthedocs.io/en/latest/api_objective.html\#pypesto.objective.AmiciObjective}{\texttt{AmiciObjective}}
that is attached to the pyPESTO
\href{https://pypesto.readthedocs.io/en/latest/api_problem.html\#pypesto.problem.Problem}{\texttt{Problem}}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{23}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{amici}
\PY{n}{obj} \PY{o}{=} \PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{objective}
\PY{n}{obj}\PY{o}{.}\PY{n}{amici\PYZus{}solver}\PY{o}{.}\PY{n}{setNewtonMaxSteps}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
\PY{n}{obj}\PY{o}{.}\PY{n}{amici\PYZus{}model}\PY{o}{.}\PY{n}{setSteadyStateSensitivityMode}\PY{p}{(}
    \PY{n}{amici}\PY{o}{.}\PY{n}{SteadyStateSensitivityMode}\PY{o}{.}\PY{n}{simulationFSA}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    pyPESTO also supports extrapolation methods that iteratively update
initial guesses for steadystates by linearly extrapolating previously
found steadystates based on steadystate sensitivities. As this may lead
to issues when combined with forward, simulation based sensitivity
analysis, we deactivate this option here.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{24}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{obj}\PY{o}{.}\PY{n}{guess\PYZus{}steadystate} \PY{o}{=} \PY{k+kc}{False}
\end{Verbatim}
\end{tcolorbox}

    AMICI also supports different sensitivity analysis methods for dynamic
simulations (specified by \texttt{petab.SIMULATION\_CONDITION\_ID}) \cite{2754712/MKPQ9727}. For models with over 100
parameters, it usually makes sense to use adjoint sensitivity analysis
\cite{2754712/INKV577L}. However, for models that also require
preequilibration, the computation time of the simulation and gradient
evaluation may be dominated by preequilibration and the choice of
sensitivity method for dynamic simulations may have negligible
impact on computation time. Accordingly, other considerations, such as
the availability of approximate second order information should be taken
into account when selecting the sensitivity method. In contrast to
forward sensitivity analysis, adjoint sensitivity analysis does not
provide an approximation to the Hessian of the objective function
\cite{2754712/MKPQ9727}, rendering some optimizers inapplicable and
potentially reducing the convergence rate of those that remain
applicable. Therefore, we here chose forward sensitivity analysis for
dynamic simulations.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{25}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{obj}\PY{o}{.}\PY{n}{amici\PYZus{}solver}\PY{o}{.}\PY{n}{setSensitivityMethod}\PY{p}{(}\PY{n}{amici}\PY{o}{.}\PY{n}{SensitivityMethod}\PY{o}{.}\PY{n}{forward}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Another set of crucial parameters to tune are integration step limits
and tolerances. Lower tolerances generally improve accuracy of the
objective function and its derivatives, which influences local
convergence rate and success \cite{2754712/RUR9I9SQ}
\cite{2754712/9T4L23VZ}. However, lower tolerances also increases the
computation time \cite{2754712/ICNACSXA}, so fewer optimization
iterations could easily be offsetted by longer compute times per
iteration. Moreover, both integration tolerances and step limits
influence numerical integrability \cite{2754712/ICNACSXA}, which can
lead to complications during optimization. Low step
limits can promote numerical integration failure and, thereby, prevent optimization from exploring difficult to
integrate parameter regions. However, if parameters from these regions yield
good fits to the data, this can also deteriorate or bias calibration. Accordingly, setting adequate values for step limits and
tolerances is integral for model calibration. Nevertheless, there are
little to no theoretical or practical guidelines on how to choose
adequate values. Ranges of \(10^{-8}\) to \(10^{-12}\) are usually
adequate \cite{2754712/ICNACSXA}, but most of the time values are chosen
and updated empirically. Here we chose tolerances of \(10^{-12}\) and a
step limit of \(10^{5}\) integration steps, which is rather
conservative, but ensures adequate local convergence for the considered problem.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{26}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{obj}\PY{o}{.}\PY{n}{amici\PYZus{}solver}\PY{o}{.}\PY{n}{setAbsoluteTolerance}\PY{p}{(}\PY{l+m+mf}{1e\PYZhy{}12}\PY{p}{)}
\PY{n}{obj}\PY{o}{.}\PY{n}{amici\PYZus{}solver}\PY{o}{.}\PY{n}{setRelativeTolerance}\PY{p}{(}\PY{l+m+mf}{1e\PYZhy{}12}\PY{p}{)}
\PY{n}{obj}\PY{o}{.}\PY{n}{amici\PYZus{}solver}\PY{o}{.}\PY{n}{setMaxSteps}\PY{p}{(}\PY{n+nb}{int}\PY{p}{(}\PY{l+m+mf}{1e5}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Even with tuned integration tolerances and step limits, integration
failures, which prevent evaluation of the objective function and it's
derivatives, is usually inevitable. While some optimizers are able to
continue after integration failures by rejecting the respective
parameter update, it is impossible to recover from an integration
failure in the first iteration, i.e., during initialization. To still ensure that a sufficient number
 of optimization runs is performed, pyPESTO enables resampling of
starting points, which generates new proposals until the objective
function could be successfully evaluated at all points. In the
following, we activate this behaviour by passing an
\href{https://pypesto.readthedocs.io/en/latest/api_optimize.html\#pypesto.optimize.OptimizeOptions}{\texttt{OptimizeOptions}}
object with the respective setting activated.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{27}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pypesto}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{OptimizeOptions}
\PY{n}{optimize\PYZus{}options} \PY{o}{=} \PY{n}{OptimizeOptions}\PY{p}{(}\PY{n}{startpoint\PYZus{}resample}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    As gradient based methods are local methods, they only, theoretically, have guaranteed convergence to local minima and multiple repeated optimization runs initialized at different points in $\Theta$ have to be started to explore the objective function landscape~\cite{2754712/NDTJEJ2U}. Selecting an appropriate number of optimization runs can be challenging,
but should generally be adapted to the downstream analysis. For example,
when model selection or uncertainty analysis using profile likelihoods
will be performed, it is crucial to ensure that optimization reaches a
local optimum and that the local optimum is, or at least yields a fit
equivalent to, the global optimum. This can be achieved by running many
optimization runs and allocating a large computational budget for each
run. For large models, it is usually not possible to allocate an overall computational budget that is sufficient to achieve these goals and the number of runs and the
computational budget per run has to be limited, with an unknown tradeoff between
the two. To deal with this tradeoff, we will here use a two-staged
approach where we first run many starts with a low computational budget
of 10 minutes. This will just be enough for a handful of iterations and
we will then select the most promising runs and continue optimization
with a larger computational budget. As optimizer, we employ fides
\cite{2754712/RUR9I9SQ}, a high performance trust-region optimizer
permitting the direct specification of the computational budgets, which
can be interfaced in pyPESTO using the
\href{https://pypesto.readthedocs.io/en/latest/api_optimize.html\#pypesto.optimize.FidesOptimizer}{\texttt{FidesOptimizer}}
class.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{28}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pypesto}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{FidesOptimizer}
\PY{k+kn}{import} \PY{n+nn}{fides}
\PY{k+kn}{import} \PY{n+nn}{logging}

\PY{n}{optimizer} \PY{o}{=} \PY{n}{FidesOptimizer}\PY{p}{(}\PY{n}{options}\PY{o}{=}\PY{p}{\PYZob{}}\PY{n}{fides}\PY{o}{.}\PY{n}{Options}\PY{o}{.}\PY{n}{MAXTIME}\PY{p}{:} \PY{l+m+mi}{600}\PY{p}{\PYZcb{}}\PY{p}{,}
                           \PY{n}{verbose}\PY{o}{=}\PY{n}{logging}\PY{o}{.}\PY{n}{ERROR}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Now we have everything at hand to run the first calibration stage. Here,
we run 100 optimization runs with uniformly sampled starting points
using the pyPESTO
\href{https://pypesto.readthedocs.io/en/latest/api_optimize.html\#pypesto.optimize.minimize}{\texttt{minimize}}
function. The calibration is parallelized using pyPESTOs
\href{https://pypesto.readthedocs.io/en/latest/api_engine.html\#pypesto.engine.MultiThreadEngine}{\texttt{MultiThreadEngine}}
with 4 threads.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{29}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pypesto}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{minimize}
\PY{n}{result} \PY{o}{=} \PY{n}{minimize}\PY{p}{(}
    \PY{n}{pypesto\PYZus{}problem}\PY{p}{,} \PY{n}{optimizer}\PY{p}{,} \PY{n}{n\PYZus{}starts}\PY{o}{=}\PY{l+m+mi}{100}\PY{p}{,} \PY{n}{options}\PY{o}{=}\PY{n}{optimize\PYZus{}options}\PY{p}{,}
    \PY{n}{startpoint\PYZus{}method}\PY{o}{=}\PY{n}{pypesto}\PY{o}{.}\PY{n}{startpoint}\PY{o}{.}\PY{n}{uniform}\PY{p}{,}
    \PY{n}{engine}\PY{o}{=}\PY{n}{pypesto}\PY{o}{.}\PY{n}{engine}\PY{o}{.}\PY{n}{MultiThreadEngine}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{,}
    \PY{n}{progress\PYZus{}bar}\PY{o}{=}\PY{k+kc}{False}\PY{p}{,}
\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    To assess the quality of the calibration, we will now use the PEtab
visualization feature. The visualization instructions are specified in a
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#visualization-table}{\texttt{visualization\ table}},
where, in the case of line plots, every row corresponds to a single pair
of connected lines for data and simulation. Here we make use of the of
the \texttt{petab.DATASET\_ID} values that we specified in the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#measurement-table}{\texttt{measurement\ table}}.
In the following we will generate seperate plots for each observable and
each inhibitor, where every plot shows the dose response in the EGF
stimulated and unstimulated condition.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{30}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{visualization\PYZus{}table} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{[}
    \PY{p}{\PYZob{}}
        \PY{n}{petab}\PY{o}{.}\PY{n}{PLOT\PYZus{}ID}\PY{p}{:} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{rafi}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+si}{\PYZob{}}\PY{n}{obs}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{PLOT\PYZus{}TYPE\PYZus{}SIMULATION}\PY{p}{:} \PY{n}{petab}\PY{o}{.}\PY{n}{LINE\PYZus{}PLOT}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{PLOT\PYZus{}TYPE\PYZus{}DATA}\PY{p}{:} \PY{n}{petab}\PY{o}{.}\PY{n}{MEAN\PYZus{}AND\PYZus{}SD}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{DATASET\PYZus{}ID}\PY{p}{:} \PY{n}{condition}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{X\PYZus{}VALUES}\PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{RAFi\PYZus{}0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{Y\PYZus{}VALUES}\PY{p}{:} \PY{n}{obs}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{X\PYZus{}SCALE}\PY{p}{:} \PY{n}{petab}\PY{o}{.}\PY{n}{LOG10}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{X\PYZus{}LABEL}\PY{p}{:} \PY{n}{rafi}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{Y\PYZus{}LABEL}\PY{p}{:} \PY{n}{obs}\PY{p}{,}
        \PY{n}{petab}\PY{o}{.}\PY{n}{LEGEND\PYZus{}ENTRY}\PY{p}{:} \PY{n}{condition}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
    \PY{p}{\PYZcb{}}
    \PY{k}{for} \PY{n}{rafi} \PY{o+ow}{in} \PY{n}{RAFis}
    \PY{k}{for} \PY{n}{obs} \PY{o+ow}{in} \PY{n}{observables\PYZus{}table}\PY{o}{.}\PY{n}{index}
    \PY{k}{for} \PY{n}{condition} \PY{o+ow}{in} \PY{n}{measurement\PYZus{}table}\PY{p}{[}\PY{n}{petab}\PY{o}{.}\PY{n}{DATASET\PYZus{}ID}\PY{p}{]}\PY{o}{.}\PY{n}{unique}\PY{p}{(}\PY{p}{)}
    \PY{k}{if} \PY{n}{condition}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{==} \PY{n}{rafi}
\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}
        
    While experimental data for visualization is already available in the
\href{https://petab.readthedocs.io/en/latest/documentation_data_format.html\#measurement-table}{\texttt{measurement\ table}},
simulations of the calibrated model still have to be computed. To
generate model simulations, we extract the parameter
values of the best pre-calibration. As optimization
results are sorted in increasing order of objective function values,
this can be achieved by taking the result at the first index. PEtab compatible simulation
results can be extracted using the pyPESTO objective and the amici
function
\href{https://amici.readthedocs.io/en/latest/generated/amici.petab_objective.html\#amici.petab_objective.rdatas_to_measurement_df}{\texttt{amici.petab\_objective.rdatas\_to\_simulation\_df}}.
As the results contains the full parameter vector including parameter
values that were not estimated, but the objective only expects estimated
parameters, the parameters need to be subsetted according to the free
indices.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{32}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{x} \PY{o}{=} \PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{get\PYZus{}reduced\PYZus{}vector}\PY{p}{(}\PY{n}{result}\PY{o}{.}\PY{n}{optimize\PYZus{}result}\PY{o}{.}\PY{n}{list}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                                       \PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{x\PYZus{}free\PYZus{}indices}\PY{p}{)}
\PY{n}{simulation} \PY{o}{=} \PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{objective}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{return\PYZus{}dict}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
\PY{n}{simulation\PYZus{}df} \PY{o}{=} \PY{n}{amici}\PY{o}{.}\PY{n}{petab\PYZus{}objective}\PY{o}{.}\PY{n}{rdatas\PYZus{}to\PYZus{}simulation\PYZus{}df}\PY{p}{(}
    \PY{n}{simulation}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{rdatas}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
    \PY{n}{model}\PY{o}{=}\PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{objective}\PY{o}{.}\PY{n}{amici\PYZus{}model}\PY{p}{,}
    \PY{n}{measurement\PYZus{}df}\PY{o}{=}\PY{n}{measurement\PYZus{}table}\PY{p}{,}
\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    We can now visualize both data and simulation using
\href{https://petab.readthedocs.io/projects/libpetab-python/en/latest/build/_autosummary/petab.visualize.plot_data_and_simulation.html\#petab.visualize.plot_data_and_simulation}{\texttt{petab.visualize.plot\_data\_and\_simulation}}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{34}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{petab}\PY{n+nn}{.}\PY{n+nn}{visualize}
\PY{n}{petab}\PY{o}{.}\PY{n}{visualize}\PY{o}{.}\PY{n}{plot\PYZus{}data\PYZus{}and\PYZus{}simulation}\PY{p}{(}
    \PY{n}{exp\PYZus{}data}\PY{o}{=}\PY{n}{measurement\PYZus{}table}\PY{p}{,}
    \PY{n}{exp\PYZus{}conditions}\PY{o}{=}\PY{n}{condition\PYZus{}table}\PY{p}{,}
    \PY{n}{sim\PYZus{}data}\PY{o}{=}\PY{n}{simulation\PYZus{}df}\PY{p}{,}
    \PY{n}{vis\PYZus{}spec}\PY{o}{=}\PY{n}{visualization\PYZus{}table}
\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_78_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    The generated figure suggests that model simulations are qualitatively similar to training data, but there are still large quantitative differences.
This suggests that the pre-calibrated parameter values are an adequate first
guess, but require further refinement.

Before we proceed with the second calibration round, we can check the
accuracy of the objective function gradient at the pre-calibrated
parameter values. For this purpose, we use the
\href{https://pypesto.readthedocs.io/en/latest/api_objective.html\#pypesto.objective.ObjectiveBase.check_grad_multi_eps}{\texttt{check\_grad\_multi\_eps}}
method, which approximates the objective function gradient using finite
differences with different step sizes.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{35}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{obj}\PY{o}{.}\PY{n}{check\PYZus{}grad\PYZus{}multi\PYZus{}eps}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{multi\PYZus{}eps}\PY{o}{=}\PY{p}{[}\PY{l+m+mf}{1e\PYZhy{}1}\PY{p}{,} \PY{l+m+mf}{1e\PYZhy{}3}\PY{p}{,} \PY{l+m+mf}{1e\PYZhy{}5}\PY{p}{]}\PY{p}{,} \PY{n}{verbosity}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{35}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
                                                  grad         fd\_f  \textbackslash{}
bind\_RAF\_RAF\_Ea                              -0.136409    -0.130195
bind\_RAF\_RAF\_dG                              39.621663    39.807356
ep\_RAF\_RAF\_mod\_RASstategtp\_double\_ddG       185.998471   186.625169
bind\_RASstategtp\_RAF\_Ea                      85.113639    85.763667
bind\_RASstategtp\_RAF\_dG                     347.268958   347.943610

                                                  fd\_b         fd\_c    fd\_err  \textbackslash{}
bind\_RAF\_RAF\_Ea                              -0.142863    -0.136529  0.012668
bind\_RAF\_RAF\_dG                              39.430721    39.619038  0.376636
ep\_RAF\_RAF\_mod\_RASstategtp\_double\_ddG       185.366301   185.995735  1.258868
bind\_RASstategtp\_RAF\_Ea                      84.461620    85.112643  1.302047
bind\_RASstategtp\_RAF\_dG                     346.594522   347.269066  1.349088

                                                abs\_err       rel\_err      eps
bind\_RAF\_RAF\_Ea                            1.199376e-04  8.849575e-04  0.00100
bind\_RAF\_RAF\_dG                            2.624273e-03  6.623599e-05  0.00100
ep\_RAF\_RAF\_mod\_RASstategtp\_double\_ddG      2.735913e-03  1.470947e-05  0.00100
bind\_RASstategtp\_RAF\_Ea                    9.959108e-04  1.170109e-05  0.00001
bind\_RASstategtp\_RAF\_dG                    1.081068e-04  3.113056e-07  0.00001
\end{Verbatim}
\end{tcolorbox}
        
    The method computes forward (\texttt{fd\_c}), backward (\texttt{fd\_b})
and central (\texttt{fd\_c}) finite differences and compares them to the
sensitivity based gradient (\texttt{grad}), using the step size
\texttt{eps} that yields the lowest finite difference approximation
error among the provided step sizes. The results show a low error in the
finite difference approximation (\texttt{fd\_err}), indicating accurate
evaluation of the objective function. Moreover, the small absolute
(\texttt{abs\_err}) and relative difference (\texttt{rel\_err}) between
sensitivity based gradient and finite difference approximation indicates
accurate evaluation of the gradient. The large magnitude of the gradient
suggest that we did not yet reach a local optimum and that further
optimization will likely improve agreement between data and simulation. In cases where either \texttt{fd\_err}, \texttt{abs\_err} or \texttt{rel\_err} take large values, it recommended to decrease integration tolerances until adequate numbers are achieved, where entries in \texttt{grad} can serve as reference. 

We will now perfom this refinement by instantiating a new optimizer with
a larger computational budget of one hour.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{36}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{optimizer\PYZus{}fine} \PY{o}{=} \PY{n}{FidesOptimizer}\PY{p}{(}\PY{n}{options}\PY{o}{=}\PY{p}{\PYZob{}}\PY{n}{fides}\PY{o}{.}\PY{n}{Options}\PY{o}{.}\PY{n}{MAXTIME}\PY{p}{:} \PY{l+m+mi}{7200}\PY{p}{\PYZcb{}}\PY{p}{,}
                                \PY{n}{verbose}\PY{o}{=}\PY{n}{logging}\PY{o}{.}\PY{n}{ERROR}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    To initialize the second calibration round at the pre-calibrated
parameter values, we extract the respective values from the results
object and set them as guesses in the pypesto problem.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{37}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{n\PYZus{}refine} \PY{o}{=} \PY{l+m+mi}{10}
\PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{x\PYZus{}guesses\PYZus{}full} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{vstack}\PY{p}{(}\PY{n}{result}\PY{o}{.}\PY{n}{optimize\PYZus{}result}\PY{o}{.}\PY{n}{get\PYZus{}for\PYZus{}key}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{[}\PY{p}{:}\PY{n}{n\PYZus{}refine}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    For startpoint generation, pypesto will first start optimization runs at
the provided parameter guesses and only sample new startpoint if more
optimization runs than guesses are requested. As for the first
calibration run, we run the calibration using the pyPESTO
\href{https://pypesto.readthedocs.io/en/latest/api_optimize.html\#pypesto.optimize.minimize}{\texttt{minimize}}
function.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{38}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{result\PYZus{}refined} \PY{o}{=} \PY{n}{minimize}\PY{p}{(}
    \PY{n}{pypesto\PYZus{}problem}\PY{p}{,} \PY{n}{optimizer\PYZus{}fine}\PY{p}{,} \PY{n}{n\PYZus{}starts}\PY{o}{=}\PY{n}{n\PYZus{}refine}\PY{p}{,}
    \PY{n}{engine}\PY{o}{=}\PY{n}{pypesto}\PY{o}{.}\PY{n}{engine}\PY{o}{.}\PY{n}{MultiThreadEngine}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{,}
    \PY{n}{progress\PYZus{}bar}\PY{o}{=}\PY{k+kc}{False}\PY{p}{,}
\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    As for pre-calibration, we now visualize the results using
\texttt{petab} and the previously constructed visualization table.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{39}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{x} \PY{o}{=} \PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{get\PYZus{}reduced\PYZus{}vector}\PY{p}{(}
    \PY{n}{result\PYZus{}refined}\PY{o}{.}\PY{n}{optimize\PYZus{}result}\PY{o}{.}\PY{n}{list}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
    \PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{x\PYZus{}free\PYZus{}indices}
\PY{p}{)}
\PY{n}{simulation} \PY{o}{=} \PY{n}{pypesto\PYZus{}problem}\PY{o}{.}\PY{n}{objective}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{return\PYZus{}dict}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
\PY{n}{simulation\PYZus{}df} \PY{o}{=} \PY{n}{amici}\PY{o}{.}\PY{n}{petab\PYZus{}objective}\PY{o}{.}\PY{n}{rdatas\PYZus{}to\PYZus{}simulation\PYZus{}df}\PY{p}{(}
    \PY{n}{simulation}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{rdatas}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
    \PY{n}{model}\PY{o}{=}\PY{n}{importer}\PY{o}{.}\PY{n}{create\PYZus{}model}\PY{p}{(}\PY{p}{)}\PY{p}{,}
    \PY{n}{measurement\PYZus{}df}\PY{o}{=}\PY{n}{measurement\PYZus{}table}\PY{p}{,}
\PY{p}{)}

\PY{n}{petab}\PY{o}{.}\PY{n}{visualize}\PY{o}{.}\PY{n}{plot\PYZus{}data\PYZus{}and\PYZus{}simulation}\PY{p}{(}
    \PY{n}{exp\PYZus{}data}\PY{o}{=}\PY{n}{measurement\PYZus{}table}\PY{p}{,}
    \PY{n}{exp\PYZus{}conditions}\PY{o}{=}\PY{n}{condition\PYZus{}table}\PY{p}{,}
    \PY{n}{sim\PYZus{}data}\PY{o}{=}\PY{n}{simulation\PYZus{}df}\PY{p}{,}
    \PY{n}{vis\PYZus{}spec}\PY{o}{=}\PY{n}{visualization\PYZus{}table}
\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_88_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    These generated figure now indicate adequate agreement between experimental data and
model simulations. As a last step of the analysis, we now compare the
objective function values across both calibration rounds using a
waterfall plot.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{40}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{pypesto}\PY{n+nn}{.}\PY{n+nn}{visualize} \PY{k+kn}{import} \PY{n}{waterfall}
\PY{n}{waterfall}\PY{p}{(}\PY{n}{results}\PY{o}{=}\PY{p}{[}\PY{n}{result}\PY{p}{,}\PY{n}{result\PYZus{}refined}\PY{p}{]}\PY{p}{,}
          \PY{n}{legends}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pre\PYZhy{}calibration}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{calibration}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_90_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    The generated waterfall plot shows sorted objective function values of different
optimizer runs for pre-calibration and calibration. The objective
function values are normalized to the best objective function value
achieved across both runs. We observe that for the majority of fully
calibrated runs, we achieve much lower objective function values
compared to the pre-calibrated runs, indicating that the higher
computational budget facilitated better fits. For a small subset of
starts, we observe repeated convergence to similar objective function
values that form a plateau in the waterfall plot, suggesting that the
respective runs may have converged to the same local minimum. Ideally,
the majority of objective function values would lie in a plateau, but
this would likely require many more optimizer runs with larger
computational budgets and would thus have to be performed on a computer
cluster.

    \hypertarget{discussion}{%
\section{Discussion}\label{discussion}}

Even with state-of-the-art methods the process of model formulation,
problem specification and calibration we described in this protocol
remains a labour intensive process, where good understanding of the
underlying mathemical concepts is necessary to achieve optimal, or even
adequate performance for large kinetic models. We anticipate that the
extensive description and code we provide in this protocol will serve as
an introduction to model calibration and may be used as template for
future research projects.

In terms of future developments, more automation in terms of tolerance
selection, sensitivity methods and computational budget allocation will
be necessary to improve accessibility of methods and reduce user
interaction. Some frameworks such as data2dynamics
\cite{2754712/RYRYBYZA} already provide adaptive tolerance updating
schemes in cases of numerical integration failure. This could still be
complemented by adaptive updating of tolerances based on objective
function evaluation accuracy, but underlying mathematical theory and
good benchmark problems are missing. We are convinced that the
introduction of large benchmarks in \cite{2754712/FMD3RVCR}
\cite{2754712/INKV577L}, guidelines for their evaluation
\cite{2754712/NYMSV8TA} as well as the standardization of their
formulation \cite{2754712/86CV69R2} will be crucial to improve
automation of model calibration.

\bibliographystyle{unsrt}
\bibliography{chapter.bib}
    
    
\end{document}

